name: Manual Service Deploy

# Manual workflow for deploying individual services
# Useful for hotfixes, testing, or redeploying specific services

on:
  workflow_dispatch:
    inputs:
      service_name:
        description: 'Service to deploy'
        required: true
        type: choice
        options:
          - 'config-server'
          - 'discovery-server'
          - 'api-gateway'
          - 'analytics-service'
          - 'bff-service'
          - 'feedback-service'
          - 'gamification-service'
          - 'notification-service'
          - 'payment-service'
          - 'practice-service'
          - 'task-service'
          - 'user-service'
      
      environment:
        description: 'Target environment'
        required: true
        type: choice
        default: 'dev'
        options:
          - 'dev'
          - 'staging'
          - 'prod'
      
      force_rebuild:
        description: 'Force rebuild (ignore cache)'
        required: false
        type: boolean
        default: false
      
      image_tag:
        description: 'Specific image tag to deploy (leave empty for latest commit)'
        required: false
        type: string
      
      skip_health_check:
        description: 'Skip health check (deploy only)'
        required: false
        type: boolean
        default: false

# Note: This workflow uses repository secrets directly
# No secrets input needed for workflow_dispatch

env:
  AWS_REGION: eu-west-1
  ECR_REGISTRY: 962496666337.dkr.ecr.eu-west-1.amazonaws.com
  ECR_REPOSITORY_PREFIX: sdt/${{ inputs.environment }}

jobs:
  validate-inputs:
    name: Validate Deployment Inputs
    runs-on: ubuntu-latest
    outputs:
      service_path: ${{ steps.validate.outputs.service_path }}
      service_port: ${{ steps.validate.outputs.service_port }}
      image_tag: ${{ steps.validate.outputs.image_tag }}
      is_infra_service: ${{ steps.validate.outputs.is_infra_service }}
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
      
      - name: Validate service and set paths
        id: validate
        run: |
          SERVICE="${{ inputs.service_name }}"
          
          # Define service mappings (matching main workflow)
          case "$SERVICE" in
            "config-server")
              echo "service_path=skilltracker-infra/config-server" >> $GITHUB_OUTPUT
              echo "service_port=8081" >> $GITHUB_OUTPUT
              echo "is_infra_service=true" >> $GITHUB_OUTPUT
              ;;
            "discovery-server")
              echo "service_path=skilltracker-infra/discovery-server" >> $GITHUB_OUTPUT
              echo "service_port=8082" >> $GITHUB_OUTPUT
              echo "is_infra_service=true" >> $GITHUB_OUTPUT
              ;;
            "api-gateway")
              echo "service_path=skilltracker-infra/api-gateway" >> $GITHUB_OUTPUT
              echo "service_port=8080" >> $GITHUB_OUTPUT
              echo "is_infra_service=true" >> $GITHUB_OUTPUT
              ;;
            "analytics-service")
              echo "service_path=skilltracker-services/analytics-service" >> $GITHUB_OUTPUT
              echo "service_port=8086" >> $GITHUB_OUTPUT
              echo "is_infra_service=false" >> $GITHUB_OUTPUT
              ;;
            "bff-service")
              echo "service_path=skilltracker-services/bff-service" >> $GITHUB_OUTPUT
              echo "service_port=8083" >> $GITHUB_OUTPUT
              echo "is_infra_service=false" >> $GITHUB_OUTPUT
              ;;
            "feedback-service")
              echo "service_path=skilltracker-services/feedback-service" >> $GITHUB_OUTPUT
              echo "service_port=8090" >> $GITHUB_OUTPUT
              echo "is_infra_service=false" >> $GITHUB_OUTPUT
              ;;
            "gamification-service")
              echo "service_path=skilltracker-services/gamification-service" >> $GITHUB_OUTPUT
              echo "service_port=8088" >> $GITHUB_OUTPUT
              echo "is_infra_service=false" >> $GITHUB_OUTPUT
              ;;
            "notification-service")
              echo "service_path=skilltracker-services/notification-service" >> $GITHUB_OUTPUT
              echo "service_port=8091" >> $GITHUB_OUTPUT
              echo "is_infra_service=false" >> $GITHUB_OUTPUT
              ;;
            "payment-service")
              echo "service_path=skilltracker-services/payment-service" >> $GITHUB_OUTPUT
              echo "service_port=8087" >> $GITHUB_OUTPUT
              echo "is_infra_service=false" >> $GITHUB_OUTPUT
              ;;
            "practice-service")
              echo "service_path=skilltracker-services/practice-service" >> $GITHUB_OUTPUT
              echo "service_port=8089" >> $GITHUB_OUTPUT
              echo "is_infra_service=false" >> $GITHUB_OUTPUT
              ;;
            "task-service")
              echo "service_path=skilltracker-services/task-service" >> $GITHUB_OUTPUT
              echo "service_port=8085" >> $GITHUB_OUTPUT
              echo "is_infra_service=false" >> $GITHUB_OUTPUT
              ;;
            "user-service")
              echo "service_path=skilltracker-services/user-service" >> $GITHUB_OUTPUT
              echo "service_port=8084" >> $GITHUB_OUTPUT
              echo "is_infra_service=false" >> $GITHUB_OUTPUT
              ;;
            *)
              echo "‚ùå Invalid service name: $SERVICE"
              exit 1
              ;;
          esac
          
          # Determine image tag
          if [ -n "${{ inputs.image_tag }}" ]; then
            IMAGE_TAG="${{ inputs.image_tag }}"
          else
            IMAGE_TAG="${{ github.sha }}"
          fi
          echo "image_tag=$IMAGE_TAG" >> $GITHUB_OUTPUT
          
          echo "‚úÖ Service validated: $SERVICE"
          echo "üìÅ Path: $(cat $GITHUB_OUTPUT | grep service_path | cut -d= -f2)"
          echo "üè∑Ô∏è Image tag: $IMAGE_TAG"

  build-service:
    name: Build Service Image
    runs-on: ubuntu-latest
    needs: validate-inputs
    
    steps:
      - name: Checkout backend repository
        uses: actions/checkout@v4
        with:
          repository: ${{ secrets.BACKEND_REPO_NAME }}
          token: ${{ secrets.PERSONAL_ACCESS_TOKEN }}
          fetch-depth: 0
      
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}
      
      - name: Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v2
      
      - name: Check if image exists (skip build if not force rebuild)
        id: check-image
        if: inputs.force_rebuild == false
        run: |
          SERVICE_NAME="${{ inputs.service_name }}"
          IMAGE_TAG="${{ needs.validate-inputs.outputs.image_tag }}"
          
          # Check if image already exists
          if aws ecr describe-images \
            --repository-name "${{ env.ECR_REPOSITORY_PREFIX }}/$SERVICE_NAME" \
            --image-ids imageTag="$IMAGE_TAG" \
            --region ${{ env.AWS_REGION }} >/dev/null 2>&1; then
            echo "‚úÖ Image already exists: $SERVICE_NAME:$IMAGE_TAG"
            echo "skip_build=true" >> $GITHUB_OUTPUT
          else
            echo "üî® Image not found, will build: $SERVICE_NAME:$IMAGE_TAG"
            echo "skip_build=false" >> $GITHUB_OUTPUT
          fi
      
      - name: Debug backend repository structure
        run: |
          echo "üìÅ Checking backend repository structure..."
          ls -la . || echo "‚ùå Current directory listing failed"
          find . -maxdepth 2 -type d -name "*task*" || echo "‚ùå No task-related directories found"
          find . -maxdepth 2 -type d -name "*service*" || echo "‚ùå No service directories found"
          echo "üìã All directories in current path:"
          find . -maxdepth 2 -type d | head -20
      
      - name: Build and push Docker image
        if: inputs.force_rebuild == true || steps.check-image.outputs.skip_build == 'false'
        run: |
          SERVICE_NAME="${{ inputs.service_name }}"
          SERVICE_PATH="${{ needs.validate-inputs.outputs.service_path }}"
          IMAGE_TAG="${{ needs.validate-inputs.outputs.image_tag }}"
          
          echo "üî® Building $SERVICE_NAME from $SERVICE_PATH"
          echo "üìÅ Looking for: ./$SERVICE_PATH"
          
          # Check if the path exists
          if [ ! -d "./$SERVICE_PATH" ]; then
            echo "‚ùå Directory ./$SERVICE_PATH does not exist"
            echo "üìã Available directories:"
            find . -maxdepth 2 -type d | grep -E "(task|service)" || echo "No matching directories found"
            exit 1
          fi
          
          echo "‚úÖ Found service directory: ./$SERVICE_PATH"
          
          # Build Docker image (from root, like main workflow)
          echo "üî® Building Docker image..."
          docker build \
            -f ./$SERVICE_PATH/Dockerfile \
            -t $SERVICE_NAME:$IMAGE_TAG \
            .
          
          # Tag for ECR
          docker tag $SERVICE_NAME:$IMAGE_TAG \
            ${{ env.ECR_REGISTRY }}/${{ env.ECR_REPOSITORY_PREFIX }}/$SERVICE_NAME:$IMAGE_TAG
          
          docker tag $SERVICE_NAME:$IMAGE_TAG \
            ${{ env.ECR_REGISTRY }}/${{ env.ECR_REPOSITORY_PREFIX }}/$SERVICE_NAME:latest
          
          # Push to ECR
          docker push ${{ env.ECR_REGISTRY }}/${{ env.ECR_REPOSITORY_PREFIX }}/$SERVICE_NAME:$IMAGE_TAG
          docker push ${{ env.ECR_REGISTRY }}/${{ env.ECR_REPOSITORY_PREFIX }}/$SERVICE_NAME:latest
          
          echo "‚úÖ Successfully built and pushed $SERVICE_NAME:$IMAGE_TAG"
      
      - name: Skip build notification
        if: inputs.force_rebuild == false && steps.check-image.outputs.skip_build == 'true'
        run: |
          echo "‚è≠Ô∏è Skipping build - image already exists"
          echo "üè∑Ô∏è Using existing image: ${{ inputs.service_name }}:${{ needs.validate-inputs.outputs.image_tag }}"

  deploy-service:
    name: Deploy Service
    runs-on: ubuntu-latest
    needs: [validate-inputs, build-service]
    
    steps:
      - name: Checkout devops repository (for slack action)
        uses: actions/checkout@v4
      
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}
      
      - name: Deploy service with minimal update
        run: |
          SERVICE_NAME="${{ inputs.service_name }}"
          IMAGE_TAG="${{ needs.validate-inputs.outputs.image_tag }}"
          CLUSTER_NAME="sdt-${{ inputs.environment }}-cluster"
          SERVICE_FULL_NAME="sdt-${{ inputs.environment }}-$SERVICE_NAME"
          
          echo "üöÄ Deploying $SERVICE_NAME to ${{ inputs.environment }}"
          
          # Get current working task definition
          CURRENT_TASK_ARN=$(aws ecs describe-services \
            --cluster $CLUSTER_NAME \
            --services $SERVICE_FULL_NAME \
            --query 'services[0].taskDefinition' \
            --output text)
          
          if [ -z "$CURRENT_TASK_ARN" ] || [ "$CURRENT_TASK_ARN" = "None" ]; then
            echo "‚ùå Service $SERVICE_FULL_NAME not found in cluster $CLUSTER_NAME"
            exit 1
          fi
          
          echo "üìã Using current task definition: $CURRENT_TASK_ARN"
          
          # Get the full working task definition
          WORKING_TASK_DEF=$(aws ecs describe-task-definition \
            --task-definition "$CURRENT_TASK_ARN" \
            --query 'taskDefinition' \
            --output json)
          
          # Store current image for comparison
          CURRENT_IMAGE=$(echo "$WORKING_TASK_DEF" | jq -r '.containerDefinitions[0].image')
          echo "üì¶ Current image: $CURRENT_IMAGE"
          
          # Create new task definition with ONLY image change
          NEW_IMAGE="${{ env.ECR_REGISTRY }}/${{ env.ECR_REPOSITORY_PREFIX }}/$SERVICE_NAME:$IMAGE_TAG"
          NEW_TASK_DEF=$(echo "$WORKING_TASK_DEF" | jq \
            --arg NEW_IMAGE "$NEW_IMAGE" '
              # Update only the image
              .containerDefinitions[0].image = $NEW_IMAGE
              # Remove AWS-managed fields
              | del(.taskDefinitionArn, .revision, .status, .requiresAttributes, .compatibilities, .registeredAt, .registeredBy)
            ')
          
          echo "üì¶ New image: $NEW_IMAGE"
          
          # Validation: Ensure only image changed
          OLD_ENV_COUNT=$(echo "$WORKING_TASK_DEF" | jq '.containerDefinitions[0].environment | length')
          NEW_ENV_COUNT=$(echo "$NEW_TASK_DEF" | jq '.containerDefinitions[0].environment | length')
          
          if [ "$OLD_ENV_COUNT" != "$NEW_ENV_COUNT" ]; then
            echo "‚ùå Environment variables changed unexpectedly! Old: $OLD_ENV_COUNT, New: $NEW_ENV_COUNT"
            exit 1
          fi
          
          OLD_SECRETS_COUNT=$(echo "$WORKING_TASK_DEF" | jq '.containerDefinitions[0].secrets | length')
          NEW_SECRETS_COUNT=$(echo "$NEW_TASK_DEF" | jq '.containerDefinitions[0].secrets | length')
          
          if [ "$OLD_SECRETS_COUNT" != "$NEW_SECRETS_COUNT" ]; then
            echo "‚ùå Secrets changed unexpectedly! Old: $OLD_SECRETS_COUNT, New: $NEW_SECRETS_COUNT"
            exit 1
          fi
          
          echo "‚úÖ Configuration preserved - only image updated"
          
          # Register new task definition
          echo "$NEW_TASK_DEF" | jq '.' > taskdef.json
          NEW_TASK_ARN=$(aws ecs register-task-definition \
            --cli-input-json file://taskdef.json \
            --query 'taskDefinition.taskDefinitionArn' \
            --output text)
          
          echo "‚úÖ Registered new task definition: $NEW_TASK_ARN"
          
          # Deploy with new image
          echo "üöÄ Updating service..."
          aws ecs update-service \
            --cluster $CLUSTER_NAME \
            --service $SERVICE_FULL_NAME \
            --task-definition "$NEW_TASK_ARN" \
            --force-new-deployment \
            --no-cli-pager
          
          echo "‚è≥ Waiting for service to stabilize..."
          aws ecs wait services-stable \
            --cluster $CLUSTER_NAME \
            --services $SERVICE_FULL_NAME
          
          echo "‚úÖ Service $SERVICE_NAME deployed successfully!"

  health-check:
    name: Health Check Service
    runs-on: ubuntu-latest
    needs: [validate-inputs, deploy-service]
    if: inputs.skip_health_check == false
    
    steps:
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}
      
      - name: Check service health
        run: |
          SERVICE_NAME="${{ inputs.service_name }}"
          CLUSTER_NAME="sdt-${{ inputs.environment }}-cluster"
          SERVICE_FULL_NAME="sdt-${{ inputs.environment }}-$SERVICE_NAME"
          
          echo "üè• Checking health of $SERVICE_NAME..."
          
          # Get service status
          STATUS=$(aws ecs describe-services \
            --cluster $CLUSTER_NAME \
            --services $SERVICE_FULL_NAME \
            --query 'services[0].{Running:runningCount,Desired:desiredCount,Status:status}' \
            --output json)
          
          RUNNING=$(echo $STATUS | jq -r '.Running')
          DESIRED=$(echo $STATUS | jq -r '.Desired')
          SVC_STATUS=$(echo $STATUS | jq -r '.Status')
          
          echo "üìä Service Status: $SVC_STATUS"
          echo "üìä Tasks: $RUNNING/$DESIRED running"
          
          if [ "$RUNNING" -eq "$DESIRED" ] && [ "$RUNNING" -gt 0 ]; then
            echo "‚úÖ $SERVICE_NAME is healthy: $RUNNING/$DESIRED tasks running"
          else
            echo "‚ùå $SERVICE_NAME is not healthy: $RUNNING/$DESIRED tasks running"
            
            # Show recent events
            echo "üìã Recent service events:"
            aws ecs describe-services \
              --cluster $CLUSTER_NAME \
              --services $SERVICE_FULL_NAME \
              --query 'services[0].events[0:5].[createdAt,message]' \
              --output table
            
            exit 1
          fi

  notify-success:
    name: Notify Success
    runs-on: ubuntu-latest
    needs: [validate-inputs, build-service, deploy-service, health-check]
    if: always() && needs.deploy-service.result == 'success' && (needs.health-check.result == 'success' || needs.health-check.result == 'skipped')
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
      
      - name: Send success notification
        uses: ./.github/actions/slack-notify
        with:
          webhook: ${{ secrets.SLACK_WEBHOOK_URL }}
          payload: |
            {
              "text": ":rocket: Manual Service Deployment Successful",
              "attachments": [
                {
                  "color": "good",
                  "fields": [
                    { "title": "‚úÖ Status", "value": "Manual deployment completed successfully", "short": true },
                    { "title": "üéØ Service", "value": "${{ inputs.service_name }}", "short": true },
                    { "title": "üåç Environment", "value": "${{ inputs.environment }}", "short": true },
                    { "title": "üè∑Ô∏è Image Tag", "value": "${{ needs.validate-inputs.outputs.image_tag }}", "short": true },
                    { "title": "üî® Force Rebuild", "value": "${{ inputs.force_rebuild }}", "short": true },
                    { "title": "üè• Health Check", "value": "${{ inputs.skip_health_check && 'Skipped' || 'Passed' }}", "short": true },
                    { "title": "üë§ Triggered By", "value": "${{ github.actor }}", "short": true },
                    { "title": "üîó View Run", "value": "<${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}|GitHub Actions>", "short": true }
                  ],
                  "footer": "Manual Service Deployment",
                  "footer_icon": "https://github.githubassets.com/favicon.ico"
                }
              ]
            }

  notify-failure:
    name: Notify Failure
    runs-on: ubuntu-latest
    needs: [validate-inputs, build-service, deploy-service, health-check]
    if: always() && (needs.build-service.result == 'failure' || needs.deploy-service.result == 'failure' || needs.health-check.result == 'failure')
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
      
      - name: Determine failure stage
        id: failure-stage
        run: |
          if [ "${{ needs.build-service.result }}" == "failure" ]; then
            echo "stage=Build" >> $GITHUB_OUTPUT
            echo "message=Failed to build Docker image" >> $GITHUB_OUTPUT
          elif [ "${{ needs.deploy-service.result }}" == "failure" ]; then
            echo "stage=Deploy" >> $GITHUB_OUTPUT  
            echo "message=Failed to deploy service to ECS" >> $GITHUB_OUTPUT
          elif [ "${{ needs.health-check.result }}" == "failure" ]; then
            echo "stage=Health Check" >> $GITHUB_OUTPUT
            echo "message=Service deployment succeeded but health check failed" >> $GITHUB_OUTPUT
          else
            echo "stage=Unknown" >> $GITHUB_OUTPUT
            echo "message=Unknown failure occurred" >> $GITHUB_OUTPUT
          fi
      
      - name: Send failure notification
        uses: ./.github/actions/slack-notify
        with:
          webhook: ${{ secrets.SLACK_WEBHOOK_URL }}
          payload: |
            {
              "text": ":x: Manual Service Deployment Failed",
              "attachments": [
                {
                  "color": "danger",
                  "fields": [
                    { "title": "‚ùå Status", "value": "Manual deployment failed", "short": true },
                    { "title": "üö® Failed Stage", "value": "${{ steps.failure-stage.outputs.stage }}", "short": true },
                    { "title": "üéØ Service", "value": "${{ inputs.service_name }}", "short": true },
                    { "title": "üåç Environment", "value": "${{ inputs.environment }}", "short": true },
                    { "title": "üè∑Ô∏è Image Tag", "value": "${{ needs.validate-inputs.outputs.image_tag }}", "short": true },
                    { "title": "üí¨ Error", "value": "${{ steps.failure-stage.outputs.message }}", "short": false },
                    { "title": "üë§ Triggered By", "value": "${{ github.actor }}", "short": true },
                    { "title": "üîó View Logs", "value": "<${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}|GitHub Actions>", "short": true }
                  ],
                  "footer": "Manual Service Deployment - Failed",
                  "footer_icon": "https://github.githubassets.com/favicon.ico"
                }
              ]
            }
