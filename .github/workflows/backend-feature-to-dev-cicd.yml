name: Feature to Dev CI/CD

on:
  # This is a reusable workflow that can be called from other workflows
  workflow_call:
    # Input parameters passed from the calling workflow
    inputs:
      pr_title:
        required: true
        type: string
      pr_author:
        required: true
        type: string
      pr_url:
        required: true
        type: string
      target_branch:
        required: true
        type: string
      commit_sha:
        required: true
        type: string
      enable_ecs_deploy:
        required: false
        type: boolean
        default: true
      force_full_build:
        required: false
        type: boolean
        default: false
    # Required secrets for AWS authentication, Docker registry, and notifications
    secrets:
      AWS_ACCESS_KEY_ID:
        required: true
      AWS_SECRET_ACCESS_KEY:
        required: true
      SLACK_WEBHOOK_URL:
        required: false
      PERSONAL_ACCESS_TOKEN:
        required: true
      BACKEND_REPO_NAME:
        required: true
      ARN_APP_SECRETS_JWT:
        required: true
      ARN_APP_SECRETS_OAUTH_GOOGLE:
        required: true
      ARN_APP_SECRETS_MAIL:
        required: true
      ARN_APP_SECRETS_MQ:
        required: true
      ARN_APP_SECRETS_REDIS:
        required: false
      ARN_APP_SECRETS_MONGO_ANALYTICS:
        required: true
      ARN_APP_SECRETS_MONGO_GAMIFICATION:
        required: true
      ARN_APP_SECRETS_MONGO_NOTIFICATION:
        required: true
      ARN_APP_SECRETS_POSTGRES_SCHEMAS:
        required: false

env:
  AWS_REGION: eu-west-1
  ECR_REGISTRY: 962496666337.dkr.ecr.eu-west-1.amazonaws.com
  ECR_REPOSITORY_PREFIX: sdt/dev

jobs:
  detect-changes:
    name: Detect Changed Services
    runs-on: ubuntu-latest

    outputs:
      services_json: ${{ steps.compute.outputs.services_json }}
      business_services_json: ${{ steps.compute.outputs.business_services_json }}
      infra_any: ${{ steps.compute.outputs.infra_any }}
      infra_csv: ${{ steps.compute.outputs.infra_csv }}

    steps:
      - name: Checkout backend repository (full history)
        uses: actions/checkout@v4
        with:
          repository: ${{ secrets.BACKEND_REPO_NAME }}
          ref: ${{ inputs.commit_sha }}
          token: ${{ secrets.PERSONAL_ACCESS_TOKEN }}
          fetch-depth: 0

      - name: Install jq
        run: |
          sudo apt-get update
          sudo apt-get install -y jq

      - name: Compute changed services matrix
        id: compute
        shell: bash
        run: |
          set -euo pipefail

          # Define services mapping
          NAMES=(
            config-server discovery-server api-gateway
            bff-service user-service task-service analytics-service payment-service gamification-service practice-service feedback-service notification-service
          )
          PATHS=(
            skilltracker-infra/config-server
            skilltracker-infra/discovery-server
            skilltracker-infra/api-gateway
            skilltracker-services/bff-service
            skilltracker-services/user-service
            skilltracker-services/task-service
            skilltracker-services/analytics-service
            skilltracker-services/payment-service
            skilltracker-services/gamification-service
            skilltracker-services/practice-service
            skilltracker-services/feedback-service
            skilltracker-services/notification-service
          )
          PORTS=(8081 8082 8080 8083 8084 8085 8086 8087 8088 8089 8090 8091)

          # If manual override is enabled, output all services and exit
          if [ "${{ inputs.force_full_build }}" = "true" ]; then
            echo "force_full_build enabled: selecting ALL services"
            SERVICES_JSON='[]'
            BUSINESS_JSON='[]'
            INFRA_CSV="config-server,discovery-server,api-gateway"
            for i in "${!NAMES[@]}"; do
              name="${NAMES[$i]}"; path="${PATHS[$i]}"; port="${PORTS[$i]}"
              obj=$(jq -n --arg n "$name" --arg p "$path" --argjson port "$port" '{name:$n, path:$p, port:$port}')
              SERVICES_JSON=$(jq -c --argjson o "$obj" '. + [$o]' <<<"$SERVICES_JSON")
              case "$path" in
                skilltracker-infra/*) : ;;
                *) BUSINESS_JSON=$(jq -c --argjson o "$obj" '. + [$o]' <<<"$BUSINESS_JSON");;
              esac
            done
            echo "services_json=$SERVICES_JSON" >> "$GITHUB_OUTPUT"
            echo "business_services_json=$BUSINESS_JSON" >> "$GITHUB_OUTPUT"
            echo "infra_any=true" >> "$GITHUB_OUTPUT"
            echo "infra_csv=$INFRA_CSV" >> "$GITHUB_OUTPUT"
            exit 0
          fi

          COMMIT="${{ inputs.commit_sha }}"
          PARENT="${COMMIT}^1"
          # Fallback if parent is missing (e.g., not a merge commit)
          if ! git cat-file -e "$PARENT" 2>/dev/null; then
            PARENT="${COMMIT}^"
          fi

          echo "Comparing $PARENT..$COMMIT"
          CHANGED=$(git diff --name-only "$PARENT" "$COMMIT" || true)
          printf '%s\n' "$CHANGED"

          SERVICES_JSON='[]'
          BUSINESS_JSON='[]'
          INFRA_CSV=""

          for i in "${!NAMES[@]}"; do
            name="${NAMES[$i]}"; path="${PATHS[$i]}"; port="${PORTS[$i]}"
            if printf '%s\n' "$CHANGED" | grep -qE "^${path}/"; then
              obj=$(jq -n --arg n "$name" --arg p "$path" --argjson port "$port" '{name:$n, path:$p, port:$port}')
              SERVICES_JSON=$(jq -c --argjson o "$obj" '. + [$o]' <<<"$SERVICES_JSON")
              case "$path" in
                skilltracker-infra/*)
                  if [ -z "$INFRA_CSV" ]; then INFRA_CSV="$name"; else INFRA_CSV="$INFRA_CSV,$name"; fi
                  ;;
                *)
                  BUSINESS_JSON=$(jq -c --argjson o "$obj" '. + [$o]' <<<"$BUSINESS_JSON")
                  ;;
              esac
            fi
          done

          INFRA_ANY=false
          if [ -n "$INFRA_CSV" ]; then INFRA_ANY=true; fi

          echo "services_json=$SERVICES_JSON" >> "$GITHUB_OUTPUT"
          echo "business_services_json=$BUSINESS_JSON" >> "$GITHUB_OUTPUT"
          echo "infra_any=$INFRA_ANY" >> "$GITHUB_OUTPUT"
          echo "infra_csv=$INFRA_CSV" >> "$GITHUB_OUTPUT"

      - name: Debug changed services outputs
        run: |
          echo "services_json=${{ steps.compute.outputs.services_json }}"
          echo "business_services_json=${{ steps.compute.outputs.business_services_json }}"
          echo "infra_any=${{ steps.compute.outputs.infra_any }}"
          echo "infra_csv=${{ steps.compute.outputs.infra_csv }}"

  build-and-push:
    name: Build and Push Docker Images
    runs-on: ubuntu-latest
    needs: detect-changes
    continue-on-error: true

    strategy:
      fail-fast: false
      matrix:
        service: ${{ fromJSON(needs.detect-changes.outputs.services_json) }}

    steps:
      - name: Checkout backend repository
        uses: actions/checkout@v4
        with:
          repository: ${{ secrets.BACKEND_REPO_NAME }}
          ref: ${{ inputs.commit_sha }}
          token: ${{ secrets.PERSONAL_ACCESS_TOKEN }}
          fetch-depth: 0

      - name: Set up JDK 21
        uses: actions/setup-java@v4
        with:
          distribution: "temurin"
          java-version: "21"
          cache: "maven"

      - name: Install Maven (host)
        run: |
          sudo apt-get update
          sudo apt-get install -y maven

      - name: Build shared dependencies
        run: |
          echo "üîß Building shared dependencies first..."
          # Build common-security if it exists
          if [ -d "./common-security" ]; then
            echo "üì¶ Building common-security..."
            mvn -q clean install -DskipTests -f ./common-security/pom.xml
          elif [ -d "./shared/common-security" ]; then
            echo "üì¶ Building shared/common-security..."
            mvn -q clean install -DskipTests -f ./shared/common-security/pom.xml
          elif [ -f "./pom.xml" ]; then
            echo "üì¶ Building parent project (may include shared modules)..."
            mvn -q clean install -DskipTests -pl common-security -am 2>/dev/null || echo "No common-security module found in parent"
          else
            echo "‚ö†Ô∏è No shared dependencies found - proceeding with service build"
          fi

      - name: Prime Maven cache (host)
        run: |
          echo "üì• Downloading dependencies for ${{ matrix.service.name }}..."
          mvn -q -DskipTests -f ./${{ matrix.service.path }}/pom.xml dependency:go-offline || echo "‚ö†Ô∏è Some dependencies may be missing - will resolve during build"

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v2

      - name: Build Docker image for ${{ matrix.service.name }}
        run: |
          echo "üî® Building ${{ matrix.service.name }} on port ${{ matrix.service.port }}"
          docker build \
            -f ./${{ matrix.service.path }}/Dockerfile \
            -t ${{ env.ECR_REGISTRY }}/${{ env.ECR_REPOSITORY_PREFIX }}/${{ matrix.service.name }}:latest \
            -t ${{ env.ECR_REGISTRY }}/${{ env.ECR_REPOSITORY_PREFIX }}/${{ matrix.service.name }}:${{ inputs.commit_sha }} \
            .

      - name: Push Docker image to ECR
        run: |
          echo "üì§ Pushing ${{ matrix.service.name }} to ECR"
          docker push ${{ env.ECR_REGISTRY }}/${{ env.ECR_REPOSITORY_PREFIX }}/${{ matrix.service.name }}:latest
          docker push ${{ env.ECR_REGISTRY }}/${{ env.ECR_REPOSITORY_PREFIX }}/${{ matrix.service.name }}:${{ inputs.commit_sha }}

      - name: Image digest
        run: |
          echo "‚úÖ Successfully pushed ${{ matrix.service.name }}"
          echo "üì¶ Latest: ${{ env.ECR_REGISTRY }}/${{ env.ECR_REPOSITORY_PREFIX }}/${{ matrix.service.name }}:latest"
          echo "üì¶ Tagged: ${{ env.ECR_REGISTRY }}/${{ env.ECR_REPOSITORY_PREFIX }}/${{ matrix.service.name }}:${{ inputs.commit_sha }}"

  deploy-infra:
    name: Deploy Infra Services (ordered)
    runs-on: ubuntu-latest
    needs: [build-and-push, detect-changes]
    if: inputs.enable_ecs_deploy && needs.detect-changes.outputs.infra_any == 'true'

    steps:
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Install jq
        run: |
          sudo apt-get update
          sudo apt-get install -y jq

      - name: Deploy infra sequentially
        run: |
          set -euo pipefail

          deploy_one() {
            SERVICE_NAME="$1"
            echo "=== Deploying $SERVICE_NAME ==="

            # Resolve current task definition ARN from the service (avoids assumptions about family name)
            TASK_DEF_ARN=$(aws ecs describe-services \
              --cluster sdt-dev-cluster \
              --services sdt-dev-${SERVICE_NAME} \
              --query 'services[0].taskDefinition' \
              --output text || true)

            if [ -z "$TASK_DEF_ARN" ] || [ "$TASK_DEF_ARN" = "None" ]; then
              echo "Service sdt-dev-${SERVICE_NAME} not found or has no taskDefinition. Skipping."
              return 0
            fi

            TASK_DEF=$(aws ecs describe-task-definition \
              --task-definition "$TASK_DEF_ARN" \
              --query 'taskDefinition' \
              --output json)

            # Build ENV from SSM and SECRETS from Secrets Manager (same set used in business deploy)
            PARAMS=(
              "/sdt-dev/config/SPRING_PROFILES_ACTIVE"
              "/sdt-dev/config/LOG_LEVEL"
              "/sdt-dev/config/AWS_REGION"
              "/sdt-dev/config/CONFIG_REPO"
              "/sdt-dev/endpoints/SPRING_CLOUD_CONFIG_URI"
              "/sdt-dev/endpoints/EUREKA_CLIENT_SERVICEURL_DEFAULTZONE"
              "/sdt-dev/endpoints/BASE_URL"
              "/sdt-dev/db/JDBC_BASE"
              "/sdt-dev/mongo/analytics_db"
              "/sdt-dev/mongo/gamification_db"
              "/sdt-dev/mongo/notification_db"
            )

            PARAM_JSON=$(aws ssm get-parameters \
              --with-decryption \
              --names "${PARAMS[@]}" \
              --query 'Parameters[].{Name:Name,Value:Value}' \
              --output json)

            ENV_JSON=$(echo "$PARAM_JSON" | jq -c '[ .[] | {name: (.Name | split("/")[-1]), value: .Value} ]')

            ARN_JWT="${{ secrets.ARN_APP_SECRETS_JWT }}"
            ARN_OAUTH="${{ secrets.ARN_APP_SECRETS_OAUTH_GOOGLE }}"
            ARN_MAIL="${{ secrets.ARN_APP_SECRETS_MAIL }}"
            ARN_MQ="${{ secrets.ARN_APP_SECRETS_MQ }}"
            ARN_REDIS="${{ secrets.ARN_APP_SECRETS_REDIS }}"
            ARN_MONGO_ANALYTICS="${{ secrets.ARN_APP_SECRETS_MONGO_ANALYTICS }}"
            ARN_MONGO_GAMIFICATION="${{ secrets.ARN_APP_SECRETS_MONGO_GAMIFICATION }}"
            ARN_MONGO_NOTIFICATION="${{ secrets.ARN_APP_SECRETS_MONGO_NOTIFICATION }}"
            ARN_PG_SCHEMAS="${{ secrets.ARN_APP_SECRETS_POSTGRES_SCHEMAS }}"

            SECRETS_JSON=$(jq -c -n --arg arn_jwt "$ARN_JWT" \
                                 --arg arn_oauth "$ARN_OAUTH" \
                                 --arg arn_mail "$ARN_MAIL" \
                                 --arg arn_mq "$ARN_MQ" \
                                 --arg arn_redis "$ARN_REDIS" \
                                 --arg arn_ma "$ARN_MONGO_ANALYTICS" \
                                 --arg arn_mg "$ARN_MONGO_GAMIFICATION" \
                                 --arg arn_mn "$ARN_MONGO_NOTIFICATION" \
                                 --arg arn_pg "$ARN_PG_SCHEMAS" '
              [
                ($arn_jwt   | select(length>0) | {name:"JWT_SECRET",           valueFrom:(.+":JWT_SECRET::")}),
                ($arn_jwt   | select(length>0) | {name:"HMAC_SECRET_KEY",      valueFrom:(.+":HMAC_SECRET_KEY::")}),
                ($arn_jwt   | select(length>0) | {name:"HMAC_ALGORITHM",       valueFrom:(.+":HMAC_ALGORITHM::")}),
                ($arn_oauth | select(length>0) | {name:"GOOGLE_CLIENT_ID",     valueFrom:(.+":GOOGLE_CLIENT_ID::")}),
                ($arn_oauth | select(length>0) | {name:"GOOGLE_CLIENT_SECRET", valueFrom:(.+":GOOGLE_CLIENT_SECRET::")}),
                ($arn_mail  | select(length>0) | {name:"MAIL_USERNAME",        valueFrom:(.+":MAIL_USERNAME::")}),
                ($arn_mail  | select(length>0) | {name:"MAIL_PASSWORD",        valueFrom:(.+":MAIL_PASSWORD::")}),
                ($arn_mq    | select(length>0) | {name:"RABBITMQ_USER",        valueFrom:(.+":RABBITMQ_USER::")}),
                ($arn_mq    | select(length>0) | {name:"RABBITMQ_PASSWORD",    valueFrom:(.+":RABBITMQ_PASSWORD::")}),
                ($arn_redis | select(length>0) | {name:"REDIS_PASSWORD",       valueFrom:(.+":REDIS_PASSWORD::")}),
                ($arn_ma    | select(length>0) | {name:"MONGO_ANALYTICS_URI",  valueFrom:(.+":MONGO_ANALYTICS_URI::")}),
                ($arn_mg    | select(length>0) | {name:"MONGO_GAMIFICATION_URI", valueFrom:(.+":MONGO_GAMIFICATION_URI::")}),
                ($arn_mn    | select(length>0) | {name:"MONGO_NOTIFICATION_URI", valueFrom:(.+":MONGO_NOTIFICATION_URI::")}),
                ($arn_pg    | select(length>0) | {name:"POSTGRES_SCHEMAS",     valueFrom:(.+":POSTGRES_SCHEMAS::")})
              ] | map(select(. != null))')

            NEW_TASK_DEF=$(echo "$TASK_DEF" | jq \
              --arg IMAGE "${{ env.ECR_REGISTRY }}/${{ env.ECR_REPOSITORY_PREFIX }}/${SERVICE_NAME}:${{ inputs.commit_sha }}" \
              --argjson APP_ENV "$ENV_JSON" \
              --argjson APP_SECRETS "$SECRETS_JSON" '
                .containerDefinitions[0].image = $IMAGE
                | .containerDefinitions[0].environment = $APP_ENV
                | .containerDefinitions[0].secrets = $APP_SECRETS
                | del(.taskDefinitionArn, .revision, .status, .requiresAttributes, .compatibilities, .registeredAt, .registeredBy)
            ')

            # Validate JSON and register from file to avoid shell quoting issues
            echo "$NEW_TASK_DEF" | jq -e '.' > taskdef.json
            NEW_TASK_ARN=$(aws ecs register-task-definition \
              --cli-input-json file://taskdef.json \
              --query 'taskDefinition.taskDefinitionArn' \
              --output text)

            echo "Registered task def: $NEW_TASK_ARN"

            aws ecs update-service \
              --cluster sdt-dev-cluster \
              --service sdt-dev-${SERVICE_NAME} \
              --task-definition "$NEW_TASK_ARN" \
              --force-new-deployment \
              --no-cli-pager

            echo "Recent ECS service events for $SERVICE_NAME:"
            aws ecs describe-services \
              --cluster sdt-dev-cluster \
              --services sdt-dev-${SERVICE_NAME} \
              --query 'services[0].events[0:10].[createdAt,message]' \
              --output table || true

            echo "Describe latest tasks for $SERVICE_NAME:"
            TASK_ARNS=$(aws ecs list-tasks \
              --cluster sdt-dev-cluster \
              --service-name sdt-dev-${SERVICE_NAME} \
              --desired-status RUNNING \
              --output text --query 'taskArns')
            if [ -z "$TASK_ARNS" ]; then
              TASK_ARNS=$(aws ecs list-tasks \
                --cluster sdt-dev-cluster \
                --service-name sdt-dev-${SERVICE_NAME} \
                --desired-status STOPPED \
                --output text --query 'taskArns[0:5]')
            fi
            if [ -n "$TASK_ARNS" ]; then
              aws ecs describe-tasks \
                --cluster sdt-dev-cluster \
                --tasks $TASK_ARNS \
                --query 'tasks[].{last:lastStatus,desired:desiredStatus,stopped:stoppedReason,containers:containers[].reason}' \
                --output json || true
            else
              echo "No tasks found yet for $SERVICE_NAME."
            fi

            echo "Waiting for $SERVICE_NAME to stabilize..."
            aws ecs wait services-stable \
              --cluster sdt-dev-cluster \
              --services sdt-dev-${SERVICE_NAME}
            echo "‚úÖ $SERVICE_NAME is stable!"
          }

          # Enforce order: config -> discovery -> api-gateway
          deploy_one config-server
          deploy_one discovery-server
          deploy_one api-gateway

  deploy-business:
    name: Deploy Business Services (parallel)
    runs-on: ubuntu-latest
    needs: [deploy-infra, detect-changes]
    if: inputs.enable_ecs_deploy

    strategy:
      matrix:
        service: ${{ fromJSON(needs.detect-changes.outputs.business_services_json) }}
      max-parallel: 4

    steps:
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Get current task definition
        id: get-task-def
        run: |
          TASK_DEF=$(aws ecs describe-task-definition \
            --task-definition sdt-dev-${{ matrix.service.name }} \
            --query 'taskDefinition' \
            --output json)
          {
            echo "task-def<<EOF"
            echo "$TASK_DEF"
            echo "EOF"
          } >> $GITHUB_OUTPUT

      - name: Build environment and secrets for task
        id: env-secrets
        shell: bash
        run: |
          set -euo pipefail

          # SSM parameter names provisioned by Terraform
          PARAMS=(
            "/sdt-dev/config/SPRING_PROFILES_ACTIVE"
            "/sdt-dev/config/LOG_LEVEL"
            "/sdt-dev/config/AWS_REGION"
            "/sdt-dev/config/CONFIG_REPO"
            "/sdt-dev/endpoints/SPRING_CLOUD_CONFIG_URI"
            "/sdt-dev/endpoints/EUREKA_CLIENT_SERVICEURL_DEFAULTZONE"
            "/sdt-dev/endpoints/BASE_URL"
            "/sdt-dev/db/JDBC_BASE"
            "/sdt-dev/mongo/analytics_db"
            "/sdt-dev/mongo/gamification_db"
            "/sdt-dev/mongo/notification_db"
          )

          PARAM_JSON=$(aws ssm get-parameters \
            --with-decryption \
            --names "${PARAMS[@]}" \
            --query 'Parameters[].{Name:Name,Value:Value}' \
            --output json)

          # Convert SSM names to env var names (rightmost path segment)
          ENV_JSON=$(echo "$PARAM_JSON" | jq -c '[ .[] | {name: (.Name | split("/")[-1]), value: .Value} ]')

          # Secrets Manager ARNs from Terraform outputs (paste once; consider moving to repo env vars)
          ARN_JWT="${{ secrets.ARN_APP_SECRETS_JWT }}"
          ARN_OAUTH="${{ secrets.ARN_APP_SECRETS_OAUTH_GOOGLE }}"
          ARN_MAIL="${{ secrets.ARN_APP_SECRETS_MAIL }}"
          ARN_MQ="${{ secrets.ARN_APP_SECRETS_MQ }}"
          ARN_REDIS="${{ secrets.ARN_APP_SECRETS_REDIS }}"
          ARN_MONGO_ANALYTICS="${{ secrets.ARN_APP_SECRETS_MONGO_ANALYTICS }}"
          ARN_MONGO_GAMIFICATION="${{ secrets.ARN_APP_SECRETS_MONGO_GAMIFICATION }}"
          ARN_MONGO_NOTIFICATION="${{ secrets.ARN_APP_SECRETS_MONGO_NOTIFICATION }}"
          ARN_PG_SCHEMAS="${{ secrets.ARN_APP_SECRETS_POSTGRES_SCHEMAS }}"

          # Build generic secrets array. You may tailor per service later.
          SECRETS_JSON=$(jq -c -n --arg arn_jwt "$ARN_JWT" \
                               --arg arn_oauth "$ARN_OAUTH" \
                               --arg arn_mail "$ARN_MAIL" \
                               --arg arn_mq "$ARN_MQ" \
                               --arg arn_redis "$ARN_REDIS" \
                               --arg arn_ma "$ARN_MONGO_ANALYTICS" \
                               --arg arn_mg "$ARN_MONGO_GAMIFICATION" \
                               --arg arn_mn "$ARN_MONGO_NOTIFICATION" \
                               --arg arn_pg "$ARN_PG_SCHEMAS" '
            [
              ($arn_jwt   | select(length>0) | {name:"JWT_SECRET",                   valueFrom:(.+":JWT_SECRET::")}),
              ($arn_jwt   | select(length>0) | {name:"HMAC_SECRET_KEY",              valueFrom:(.+":HMAC_SECRET_KEY::")}),
              ($arn_jwt   | select(length>0) | {name:"HMAC_ALGORITHM",               valueFrom:(.+":HMAC_ALGORITHM::")}),
              ($arn_oauth | select(length>0) | {name:"GOOGLE_CLIENT_ID",             valueFrom:(.+":GOOGLE_CLIENT_ID::")}),
              ($arn_oauth | select(length>0) | {name:"GOOGLE_CLIENT_SECRET",         valueFrom:(.+":GOOGLE_CLIENT_SECRET::")}),
              ($arn_mail  | select(length>0) | {name:"MAIL_USERNAME",                valueFrom:(.+":MAIL_USERNAME::")}),
              ($arn_mail  | select(length>0) | {name:"MAIL_PASSWORD",                valueFrom:(.+":MAIL_PASSWORD::")}),
              ($arn_mq    | select(length>0) | {name:"RABBITMQ_USER",                valueFrom:(.+":RABBITMQ_USER::")}),
              ($arn_mq    | select(length>0) | {name:"RABBITMQ_PASSWORD",            valueFrom:(.+":RABBITMQ_PASSWORD::")}),
              ($arn_redis | select(length>0) | {name:"REDIS_PASSWORD",               valueFrom:(.+":REDIS_PASSWORD::")}),
              ($arn_ma    | select(length>0) | {name:"MONGO_ANALYTICS_USER",         valueFrom:(.+":MONGO_ANALYTICS_USER::")}),
              ($arn_ma    | select(length>0) | {name:"MONGO_ANALYTICS_PASSWORD",     valueFrom:(.+":MONGO_ANALYTICS_PASSWORD::")}),
              ($arn_mg    | select(length>0) | {name:"MONGO_GAMIFICATION_USER",      valueFrom:(.+":MONGO_GAMIFICATION_USER::")}),
              ($arn_mg    | select(length>0) | {name:"MONGO_GAMIFICATION_PASSWORD",  valueFrom:(.+":MONGO_GAMIFICATION_PASSWORD::")}),
              ($arn_mn    | select(length>0) | {name:"MONGO_NOTIFICATION_USER",      valueFrom:(.+":MONGO_NOTIFICATION_USER::")}),
              ($arn_mn    | select(length>0) | {name:"MONGO_NOTIFICATION_PASSWORD",  valueFrom:(.+":MONGO_NOTIFICATION_PASSWORD::")}),
              ($arn_pg    | select(length>0) | {name:"POSTGRES_USER_USER",           valueFrom:(.+":POSTGRES_USER_USER::")}),
              ($arn_pg    | select(length>0) | {name:"POSTGRES_USER_PASSWORD",       valueFrom:(.+":POSTGRES_USER_PASSWORD::")}),
              ($arn_pg    | select(length>0) | {name:"POSTGRES_TASK_USER",           valueFrom:(.+":POSTGRES_TASK_USER::")}),
              ($arn_pg    | select(length>0) | {name:"POSTGRES_TASK_PASSWORD",       valueFrom:(.+":POSTGRES_TASK_PASSWORD::")}),
              ($arn_pg    | select(length>0) | {name:"POSTGRES_FEEDBACK_USER",       valueFrom:(.+":POSTGRES_FEEDBACK_USER::")}),
              ($arn_pg    | select(length>0) | {name:"POSTGRES_FEEDBACK_PASSWORD",   valueFrom:(.+":POSTGRES_FEEDBACK_PASSWORD::")}),
              ($arn_pg    | select(length>0) | {name:"POSTGRES_PAYMENT_USER",        valueFrom:(.+":POSTGRES_PAYMENT_USER::")}),
              ($arn_pg    | select(length>0) | {name:"POSTGRES_PAYMENT_PASSWORD",    valueFrom:(.+":POSTGRES_PAYMENT_PASSWORD::")}),
              ($arn_pg    | select(length>0) | {name:"POSTGRES_PRACTICE_USER",       valueFrom:(.+":POSTGRES_PRACTICE_USER::")}),
              ($arn_pg    | select(length>0) | {name:"POSTGRES_PRACTICE_PASSWORD",   valueFrom:(.+":POSTGRES_PRACTICE_PASSWORD::")})
            ] | map(select(. != null))')

          echo "env_json=$ENV_JSON" >> "$GITHUB_OUTPUT"
          echo "secrets_json=$SECRETS_JSON" >> "$GITHUB_OUTPUT"

      - name: Update task definition with env, secrets and new image
        id: update-task-def
        run: |
          TASK_DEF=$(aws ecs describe-task-definition \
            --task-definition sdt-dev-${{ matrix.service.name }} \
            --query 'taskDefinition' \
            --output json)

          NEW_TASK_DEF=$(echo "$TASK_DEF" | \
            jq --arg IMAGE "${{ env.ECR_REGISTRY }}/${{ env.ECR_REPOSITORY_PREFIX }}/${{ matrix.service.name }}:${{ inputs.commit_sha }}" \
               --argjson APP_ENV '${{ steps.env-secrets.outputs.env_json }}' \
               --argjson APP_SECRETS '${{ steps.env-secrets.outputs.secrets_json }}' '
              .containerDefinitions[0].image = $IMAGE
              | .containerDefinitions[0].environment = $APP_ENV
              | .containerDefinitions[0].secrets = $APP_SECRETS
              | del(.taskDefinitionArn, .revision, .status, .requiresAttributes, .compatibilities, .registeredAt, .registeredBy)
            ')

          # Validate JSON and register from file to avoid shell quoting issues
          echo "$NEW_TASK_DEF" | jq -e '.' > taskdef.json
          NEW_TASK_ARN=$(aws ecs register-task-definition \
            --cli-input-json file://taskdef.json \
            --query 'taskDefinition.taskDefinitionArn' \
            --output text)

          echo "task-arn=$NEW_TASK_ARN" >> $GITHUB_OUTPUT
          echo "‚úÖ Registered new task definition: $NEW_TASK_ARN"

      - name: Deploy to ECS service
        run: |
          echo "üöÄ Deploying ${{ matrix.service.name }} to ECS..."
          aws ecs update-service \
            --cluster sdt-dev-cluster \
            --service sdt-dev-${{ matrix.service.name }} \
            --task-definition ${{ steps.update-task-def.outputs.task-arn }} \
            --force-new-deployment \
            --no-cli-pager

      - name: Show recent ECS service events
        run: |
          aws ecs describe-services \
            --cluster sdt-dev-cluster \
            --services sdt-dev-${{ matrix.service.name }} \
            --query 'services[0].events[0:10].[createdAt,message]' \
            --output table || true

      - name: Describe latest tasks and stopped reasons
        run: |
          TASK_ARNS=$(aws ecs list-tasks \
            --cluster sdt-dev-cluster \
            --service-name sdt-dev-${{ matrix.service.name }} \
            --desired-status RUNNING \
            --output text --query 'taskArns')
          if [ -z "$TASK_ARNS" ]; then
            TASK_ARNS=$(aws ecs list-tasks \
              --cluster sdt-dev-cluster \
              --service-name sdt-dev-${{ matrix.service.name }} \
              --desired-status STOPPED \
              --output text --query 'taskArns[0:5]')
          fi
          if [ -n "$TASK_ARNS" ]; then
            aws ecs describe-tasks \
              --cluster sdt-dev-cluster \
              --tasks $TASK_ARNS \
              --query 'tasks[].{last:lastStatus,desired:desiredStatus,stopped:stoppedReason,containers:containers[].reason}' \
              --output json || true
          else
            echo "No tasks found yet."
          fi

      - name: Wait for service stability
        run: |
          echo "‚è≥ Waiting for service to stabilize..."
          aws ecs wait services-stable \
            --cluster sdt-dev-cluster \
            --services sdt-dev-${{ matrix.service.name }}
          echo "‚úÖ Service ${{ matrix.service.name }} is stable!"

  health-check:
    name: Health Check Services
    runs-on: ubuntu-latest
    needs: deploy-business
    if: inputs.enable_ecs_deploy

    steps:
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Check ECS service health
        run: |
          echo "üè• Checking health of all services..."
          SERVICES=(
            "config-server"
            "discovery-server"
            "api-gateway"
            "bff-service"
            "user-service"
            "task-service"
            "analytics-service"
            "payment-service"
            "gamification-service"
            "practice-service"
            "feedback-service"
            "notification-service"
          )

          ALL_HEALTHY=true
          for service in "${SERVICES[@]}"; do
            echo "Checking sdt-dev-$service..."
            STATUS=$(aws ecs describe-services \
              --cluster sdt-dev-cluster \
              --services sdt-dev-$service \
              --query 'services[0].{Running:runningCount,Desired:desiredCount,Status:status}' \
              --output json)
            
            RUNNING=$(echo $STATUS | jq -r '.Running')
            DESIRED=$(echo $STATUS | jq -r '.Desired')
            
            if [ "$RUNNING" -eq "$DESIRED" ] && [ "$RUNNING" -gt 0 ]; then
              echo "‚úÖ $service: $RUNNING/$DESIRED tasks running"
            else
              echo "‚ùå $service: $RUNNING/$DESIRED tasks running"
              ALL_HEALTHY=false
            fi
          done

          if [ "$ALL_HEALTHY" = false ]; then
            echo "‚ö†Ô∏è Some services are not healthy!"
            exit 1
          fi

          echo "‚úÖ All services are healthy!"

      - name: Get ALB endpoint
        id: get-alb
        run: |
          ALB_DNS=$(aws elbv2 describe-load-balancers \
            --names sdt-dev-alb \
            --query 'LoadBalancers[0].DNSName' \
            --output text)
          echo "alb-dns=$ALB_DNS" >> $GITHUB_OUTPUT
          echo "üìç ALB Endpoint: http://$ALB_DNS"

  notify-slack:
    name: Notify Slack
    runs-on: ubuntu-latest
    needs: [build-and-push, deploy-infra, deploy-business, health-check]
    if: always()

    steps:
      - name: Checkout repository (required for local actions)
        uses: actions/checkout@v4

      - name: Determine status
        id: status
        run: |
          if [ "${{ needs.health-check.result }}" == "success" ]; then
            echo "status=success" >> $GITHUB_OUTPUT
            echo "emoji=:white_check_mark:" >> $GITHUB_OUTPUT
            echo "color=good" >> $GITHUB_OUTPUT
          elif [ "${{ needs.build-and-push.result }}" == "failure" ]; then
            echo "status=failed" >> $GITHUB_OUTPUT
            echo "emoji=:x:" >> $GITHUB_OUTPUT
            echo "color=danger" >> $GITHUB_OUTPUT
          else
            echo "status=partial" >> $GITHUB_OUTPUT
            echo "emoji=:warning:" >> $GITHUB_OUTPUT
            echo "color=warning" >> $GITHUB_OUTPUT
          fi

      - name: Send Slack notification
        uses: ./.github/actions/slack-notify
        with:
          webhook: ${{ secrets.SLACK_WEBHOOK_URL }}
          payload: |
            {
              "text": "${{ steps.status.outputs.emoji }} Backend Deployment to Dev",
              "attachments": [
                {
                  "color": "${{ steps.status.outputs.color }}",
                  "fields": [
                    { "title": "Status", "value": "${{ steps.status.outputs.status }}", "short": true },
                    { "title": "Environment", "value": "Dev", "short": true },
                    { "title": "PR Title", "value": "${{ inputs.pr_title }}", "short": false },
                    { "title": "Author", "value": "${{ inputs.pr_author }}", "short": true },
                    { "title": "Commit", "value": "<${{ inputs.pr_url }}|View PR>", "short": true },
                    { "title": "Build Result", "value": "${{ needs.build-and-push.result }}", "short": true },
                    { "title": "Deploy Results", "value": "infra: ${{ needs.deploy-infra.result }}, business: ${{ needs.deploy-business.result }}", "short": true },
                    { "title": "Health Check", "value": "${{ needs.health-check.result }}", "short": true }
                  ],
                  "footer": "GitHub Actions",
                  "footer_icon": "https://github.githubassets.com/favicon.ico"
                }
              ]
            }

  summary:
    name: Deployment Summary
    runs-on: ubuntu-latest
    needs: [build-and-push, deploy-infra, deploy-business, health-check]

    steps:
      - name: Generate summary
        run: |
          echo "## üöÄ Deployment Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

          echo "### Build & Deployment Info" >> $GITHUB_STEP_SUMMARY
          echo "- **Environment:** Dev" >> $GITHUB_STEP_SUMMARY
          echo "- **PR Title:** ${{ inputs.pr_title }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Author:** ${{ inputs.pr_author }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Target Branch:** ${{ inputs.target_branch }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Commit SHA:** \`${{ inputs.commit_sha }}\`" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

          echo "### Job Results" >> $GITHUB_STEP_SUMMARY
          echo "| Job | Status |" >> $GITHUB_STEP_SUMMARY
          echo "|-----|--------|" >> $GITHUB_STEP_SUMMARY
          echo "| Build & Push | ${{ needs.build-and-push.result }} |" >> $GITHUB_STEP_SUMMARY
          echo "| Deploy Infra | ${{ needs.deploy-infra.result }} |" >> $GITHUB_STEP_SUMMARY
          echo "| Deploy Business | ${{ needs.deploy-business.result }} |" >> $GITHUB_STEP_SUMMARY
          echo "| Health Check | ${{ needs.health-check.result }} |" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

          echo "### Services Deployed (12)" >> $GITHUB_STEP_SUMMARY
          echo "#### Infrastructure Services" >> $GITHUB_STEP_SUMMARY
          echo "- ‚úÖ Config Server (8081)" >> $GITHUB_STEP_SUMMARY
          echo "- ‚úÖ Discovery Server (8082)" >> $GITHUB_STEP_SUMMARY
          echo "- ‚úÖ API Gateway (8080)" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "#### Business Services" >> $GITHUB_STEP_SUMMARY
          echo "- ‚úÖ BFF Service (8083)" >> $GITHUB_STEP_SUMMARY
          echo "- ‚úÖ User Service (8084)" >> $GITHUB_STEP_SUMMARY
          echo "- ‚úÖ Task Service (8085)" >> $GITHUB_STEP_SUMMARY
          echo "- ‚úÖ Analytics Service (8086)" >> $GITHUB_STEP_SUMMARY
          echo "- ‚úÖ Payment Service (8087)" >> $GITHUB_STEP_SUMMARY
          echo "- ‚úÖ Gamification Service (8088)" >> $GITHUB_STEP_SUMMARY
          echo "- ‚úÖ Practice Service (8089)" >> $GITHUB_STEP_SUMMARY
          echo "- ‚úÖ Feedback Service (8090)" >> $GITHUB_STEP_SUMMARY
          echo "- ‚úÖ Notification Service (8091)" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

          echo "### Container Registry" >> $GITHUB_STEP_SUMMARY
          echo "\`\`\`" >> $GITHUB_STEP_SUMMARY
          echo "Registry: 962496666337.dkr.ecr.eu-west-1.amazonaws.com/sdt/dev/" >> $GITHUB_STEP_SUMMARY
          echo "Image Tag: ${{ inputs.commit_sha }}" >> $GITHUB_STEP_SUMMARY
          echo "\`\`\`" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

          echo "### ECS Cluster" >> $GITHUB_STEP_SUMMARY
          echo "- **Cluster:** sdt-dev-cluster" >> $GITHUB_STEP_SUMMARY
          echo "- **Region:** eu-west-1" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

          if [ "${{ needs.health-check.result }}" == "success" ]; then
            echo "### ‚úÖ Deployment Successful!" >> $GITHUB_STEP_SUMMARY
            echo "All services are healthy and running." >> $GITHUB_STEP_SUMMARY
          else
            echo "### ‚ö†Ô∏è Deployment Issues" >> $GITHUB_STEP_SUMMARY
            echo "Some jobs did not complete successfully. Check the logs above." >> $GITHUB_STEP_SUMMARY
          fi

  rollback-on-failure:
    name: Rollback Changed Services on Failure
    runs-on: ubuntu-latest
    needs: [detect-changes, deploy-infra, deploy-business, health-check]
    if: needs.health-check.result == 'failure'

    steps:
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Roll back infra services (if changed)
        if: needs.detect-changes.outputs.infra_any == 'true'
        shell: bash
        run: |
          set -euo pipefail
          IFS=',' read -r -a INFRA <<< "${{ needs.detect-changes.outputs.infra_csv }}"
          for name in "${INFRA[@]}"; do
            echo "Rolling back $name..."
            # Get previous task definition ARN (second most recent)
            PREV=$(aws ecs list-task-definitions \
              --family-prefix sdt-dev-$name \
              --sort DESC \
              --max-items 2 \
              --query 'taskDefinitionArns[-1]' \
              --output text)
            if [ -z "$PREV" ] || [ "$PREV" = "None" ]; then
              echo "No previous task definition found for $name; skipping"
              continue
            fi
            aws ecs update-service \
              --cluster sdt-dev-cluster \
              --service sdt-dev-$name \
              --task-definition "$PREV" \
              --force-new-deployment \
              --no-cli-pager
            aws ecs wait services-stable --cluster sdt-dev-cluster --services sdt-dev-$name
            echo "‚úÖ Rolled back $name to $PREV"
          done

      - name: Roll back business services (if changed)
        shell: bash
        run: |
          set -euo pipefail
          SERVICES_JSON='${{ needs.detect-changes.outputs.business_services_json }}'
          COUNT=$(jq 'length' <<<"$SERVICES_JSON")
          if [ "$COUNT" -eq 0 ]; then
            echo "No business services changed; nothing to roll back."
            exit 0
          fi
          for name in $(jq -r '.[].name' <<<"$SERVICES_JSON"); do
            echo "Rolling back $name..."
            PREV=$(aws ecs list-task-definitions \
              --family-prefix sdt-dev-$name \
              --sort DESC \
              --max-items 2 \
              --query 'taskDefinitionArns[-1]' \
              --output text)
            if [ -z "$PREV" ] || [ "$PREV" = "None" ]; then
              echo "No previous task definition found for $name; skipping"
              continue
            fi
            aws ecs update-service \
              --cluster sdt-dev-cluster \
              --service sdt-dev-$name \
              --task-definition "$PREV" \
              --force-new-deployment \
              --no-cli-pager
            aws ecs wait services-stable --cluster sdt-dev-cluster --services sdt-dev-$name
            echo "‚úÖ Rolled back $name to $PREV"
          done
