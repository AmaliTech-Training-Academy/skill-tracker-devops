name: Feature to Dev CI/CD

# PIPELINE APPROACH: Minimal Task Definition Updates
# This pipeline uses a safe "image-only" update strategy:
# 1. Gets the current working task definition from ECS
# 2. Updates ONLY the container image tag (preserves all other config)
# 3. Validates no other changes occurred
# 4. Deploys the minimal update
# 
# Benefits:
# - Preserves all Terraform-managed configuration
# - Eliminates configuration drift risks
# - Faster, safer deployments
# - Simple rollback (just previous task definition revision)

on:
  # This is a reusable workflow that can be called from other workflows
  workflow_call:
    # Input parameters passed from the calling workflow
    inputs:
      pr_title:
        required: true
        type: string
      pr_author:
        required: true
        type: string
      pr_url:
        required: true
        type: string
      target_branch:
        required: true
        type: string
      commit_sha:
        required: true
        type: string
      enable_ecs_deploy:
        required: false
        type: boolean
        default: true
      force_full_build:
        required: false
        type: boolean
        default: false
    # Required secrets for AWS authentication, Docker registry, and notifications
    secrets:
      AWS_ACCESS_KEY_ID:
        required: true
      AWS_SECRET_ACCESS_KEY:
        required: true
      SLACK_WEBHOOK_URL:
        required: false
      PERSONAL_ACCESS_TOKEN:
        required: true
      BACKEND_REPO_NAME:
        required: true
      ARN_APP_SECRETS_JWT:
        required: true
      ARN_APP_SECRETS_OAUTH_GOOGLE:
        required: true
      ARN_APP_SECRETS_MAIL:
        required: true
      ARN_APP_SECRETS_MQ:
        required: true
      ARN_APP_SECRETS_REDIS:
        required: false
      ARN_APP_SECRETS_MONGO_ANALYTICS:
        required: true
      ARN_APP_SECRETS_MONGO_GAMIFICATION:
        required: true
      ARN_APP_SECRETS_MONGO_NOTIFICATION:
        required: true
      ARN_APP_SECRETS_POSTGRES_SCHEMAS:
        required: false

env:
  AWS_REGION: eu-west-1
  ECR_REGISTRY: 962496666337.dkr.ecr.eu-west-1.amazonaws.com
  ECR_REPOSITORY_PREFIX: sdt/dev

jobs:
  detect-changes:
    name: Detect Changed Services
    runs-on: ubuntu-latest

    outputs:
      services_json: ${{ steps.compute.outputs.services_json }}
      business_services_json: ${{ steps.compute.outputs.business_services_json }}
      infra_any: ${{ steps.compute.outputs.infra_any }}
      infra_csv: ${{ steps.compute.outputs.infra_csv }}

    steps:
      - name: Checkout backend repository (full history)
        uses: actions/checkout@v4
        with:
          repository: ${{ secrets.BACKEND_REPO_NAME }}
          ref: ${{ inputs.commit_sha }}
          token: ${{ secrets.PERSONAL_ACCESS_TOKEN }}
          fetch-depth: 0

      - name: Install jq
        run: |
          sudo apt-get update
          sudo apt-get install -y jq

      - name: Compute changed services matrix
        id: compute
        shell: bash
        run: |
          set -euo pipefail

          # Define services mapping
          # FOCUS SERVICES ONLY: Core infrastructure + User service + Data services
          NAMES=(
            config-server discovery-server api-gateway
            user-service
          )
          PATHS=(
            skilltracker-infra/config-server
            skilltracker-infra/discovery-server
            skilltracker-infra/api-gateway
            skilltracker-services/user-service
          )
          PORTS=(8081 8082 8080 8084)

          # If manual override is enabled, output all services and exit
          if [ "${{ inputs.force_full_build }}" = "true" ]; then
            echo "force_full_build enabled: selecting ALL services"
            SERVICES_JSON='[]'
            BUSINESS_JSON='[]'
            INFRA_CSV="config-server,discovery-server,api-gateway"
            for i in "${!NAMES[@]}"; do
              name="${NAMES[$i]}"; path="${PATHS[$i]}"; port="${PORTS[$i]}"
              obj=$(jq -n --arg n "$name" --arg p "$path" --argjson port "$port" '{name:$n, path:$p, port:$port}')
              SERVICES_JSON=$(jq -c --argjson o "$obj" '. + [$o]' <<<"$SERVICES_JSON")
              case "$path" in
                skilltracker-infra/*) : ;;
                *) BUSINESS_JSON=$(jq -c --argjson o "$obj" '. + [$o]' <<<"$BUSINESS_JSON");;
              esac
            done
            echo "services_json<<EOF" >> "$GITHUB_OUTPUT"
            echo "$SERVICES_JSON" >> "$GITHUB_OUTPUT"
            echo "EOF" >> "$GITHUB_OUTPUT"
            
            echo "business_services_json<<EOF" >> "$GITHUB_OUTPUT"
            echo "$BUSINESS_JSON" >> "$GITHUB_OUTPUT"
            echo "EOF" >> "$GITHUB_OUTPUT"
            
            echo "infra_any=true" >> "$GITHUB_OUTPUT"
            echo "infra_csv=$INFRA_CSV" >> "$GITHUB_OUTPUT"
            exit 0
          fi

          COMMIT="${{ inputs.commit_sha }}"
          PARENT="${COMMIT}^1"
          # Fallback if parent is missing (e.g., not a merge commit)
          if ! git cat-file -e "$PARENT" 2>/dev/null; then
            PARENT="${COMMIT}^"
          fi

          echo "Comparing $PARENT..$COMMIT"
          CHANGED=$(git diff --name-only "$PARENT" "$COMMIT" || true)
          printf '%s\n' "$CHANGED"

          SERVICES_JSON='[]'
          BUSINESS_JSON='[]'
          INFRA_CSV=""

          for i in "${!NAMES[@]}"; do
            name="${NAMES[$i]}"; path="${PATHS[$i]}"; port="${PORTS[$i]}"
            if printf '%s\n' "$CHANGED" | grep -qE "^${path}/"; then
              obj=$(jq -n --arg n "$name" --arg p "$path" --argjson port "$port" '{name:$n, path:$p, port:$port}')
              SERVICES_JSON=$(jq -c --argjson o "$obj" '. + [$o]' <<<"$SERVICES_JSON")
              case "$path" in
                skilltracker-infra/*)
                  if [ -z "$INFRA_CSV" ]; then INFRA_CSV="$name"; else INFRA_CSV="$INFRA_CSV,$name"; fi
                  ;;
                *)
                  BUSINESS_JSON=$(jq -c --argjson o "$obj" '. + [$o]' <<<"$BUSINESS_JSON")
                  ;;
              esac
            fi
          done

          INFRA_ANY=false
          if [ -n "$INFRA_CSV" ]; then INFRA_ANY=true; fi

          # Output JSON arrays properly
          echo "services_json<<EOF" >> "$GITHUB_OUTPUT"
          echo "$SERVICES_JSON" >> "$GITHUB_OUTPUT"
          echo "EOF" >> "$GITHUB_OUTPUT"
          
          echo "business_services_json<<EOF" >> "$GITHUB_OUTPUT"
          echo "$BUSINESS_JSON" >> "$GITHUB_OUTPUT"
          echo "EOF" >> "$GITHUB_OUTPUT"
          
          echo "infra_any=$INFRA_ANY" >> "$GITHUB_OUTPUT"
          echo "infra_csv=$INFRA_CSV" >> "$GITHUB_OUTPUT"

      - name: Debug changed services outputs
        run: |
          echo "services_json=${{ steps.compute.outputs.services_json }}"
          echo "business_services_json=${{ steps.compute.outputs.business_services_json }}"
          echo "infra_any=${{ steps.compute.outputs.infra_any }}"
          echo "infra_csv=${{ steps.compute.outputs.infra_csv }}"

  build-and-push:
    name: Build and Push Docker Images
    runs-on: ubuntu-latest
    needs: detect-changes
    continue-on-error: true

    strategy:
      fail-fast: false
      matrix:
        service: ${{ fromJSON(needs.detect-changes.outputs.services_json) }}

    steps:
      - name: Checkout backend repository
        uses: actions/checkout@v4
        with:
          repository: ${{ secrets.BACKEND_REPO_NAME }}
          ref: ${{ inputs.commit_sha }}
          token: ${{ secrets.PERSONAL_ACCESS_TOKEN }}
          fetch-depth: 0

      - name: Set up JDK 21
        uses: actions/setup-java@v4
        with:
          distribution: "temurin"
          java-version: "21"
          cache: "maven"

      - name: Install Maven (host)
        run: |
          sudo apt-get update
          sudo apt-get install -y maven

      - name: Build shared dependencies
        run: |
          echo "ðŸ”§ Building shared dependencies first..."
          # Build common-security if it exists
          if [ -d "./common-security" ]; then
            echo "ðŸ“¦ Building common-security..."
            mvn -q clean install -DskipTests -f ./common-security/pom.xml
          elif [ -d "./shared/common-security" ]; then
            echo "ðŸ“¦ Building shared/common-security..."
            mvn -q clean install -DskipTests -f ./shared/common-security/pom.xml
          elif [ -f "./pom.xml" ]; then
            echo "ðŸ“¦ Building parent project (may include shared modules)..."
            mvn -q clean install -DskipTests -pl common-security -am 2>/dev/null || echo "No common-security module found in parent"
          else
            echo "âš ï¸ No shared dependencies found - proceeding with service build"
          fi

      - name: Prime Maven cache (host)
        run: |
          echo "ðŸ“¥ Downloading dependencies for ${{ matrix.service.name }}..."
          mvn -q -DskipTests -f ./${{ matrix.service.path }}/pom.xml dependency:go-offline || echo "âš ï¸ Some dependencies may be missing - will resolve during build"

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v2

      - name: Build Docker image for ${{ matrix.service.name }}
        run: |
          echo "ðŸ”¨ Building ${{ matrix.service.name }} on port ${{ matrix.service.port }}"
          docker build \
            -f ./${{ matrix.service.path }}/Dockerfile \
            -t ${{ env.ECR_REGISTRY }}/${{ env.ECR_REPOSITORY_PREFIX }}/${{ matrix.service.name }}:latest \
            -t ${{ env.ECR_REGISTRY }}/${{ env.ECR_REPOSITORY_PREFIX }}/${{ matrix.service.name }}:${{ inputs.commit_sha }} \
            .

      - name: Push Docker image to ECR
        run: |
          echo "ðŸ“¤ Pushing ${{ matrix.service.name }} to ECR"
          docker push ${{ env.ECR_REGISTRY }}/${{ env.ECR_REPOSITORY_PREFIX }}/${{ matrix.service.name }}:latest
          docker push ${{ env.ECR_REGISTRY }}/${{ env.ECR_REPOSITORY_PREFIX }}/${{ matrix.service.name }}:${{ inputs.commit_sha }}

      - name: Image digest
        run: |
          echo "âœ… Successfully pushed ${{ matrix.service.name }}"
          echo "ðŸ“¦ Latest: ${{ env.ECR_REGISTRY }}/${{ env.ECR_REPOSITORY_PREFIX }}/${{ matrix.service.name }}:latest"
          echo "ðŸ“¦ Tagged: ${{ env.ECR_REGISTRY }}/${{ env.ECR_REPOSITORY_PREFIX }}/${{ matrix.service.name }}:${{ inputs.commit_sha }}"

  deploy-infra:
    name: Deploy Infra Services (Image-Only Updates, Ordered)
    runs-on: ubuntu-latest
    needs: [build-and-push, detect-changes]
    if: inputs.enable_ecs_deploy && needs.detect-changes.outputs.infra_any == 'true'

    steps:
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Deploy infra services sequentially (minimal updates)
        run: |
          set -euo pipefail

          deploy_one_minimal() {
            SERVICE_NAME="$1"
            echo "=== Deploying $SERVICE_NAME (Image-Only Update) ==="

            # Get currently deployed (working) task definition
            CURRENT_TASK_ARN=$(aws ecs describe-services \
              --cluster sdt-dev-cluster \
              --services sdt-dev-${SERVICE_NAME} \
              --query 'services[0].taskDefinition' \
              --output text || true)

            if [ -z "$CURRENT_TASK_ARN" ] || [ "$CURRENT_TASK_ARN" = "None" ]; then
              echo "âŒ Service sdt-dev-${SERVICE_NAME} not found or has no taskDefinition. Skipping."
              return 0
            fi

            echo "Using working task definition: $CURRENT_TASK_ARN"

            # Get the full working task definition
            WORKING_TASK_DEF=$(aws ecs describe-task-definition \
              --task-definition "$CURRENT_TASK_ARN" \
              --query 'taskDefinition' \
              --output json)

            # Store current image for comparison
            CURRENT_IMAGE=$(echo "$WORKING_TASK_DEF" | jq -r '.containerDefinitions[0].image')
            echo "Current working image: $CURRENT_IMAGE"

            # Create new task definition with ONLY image change
            NEW_IMAGE="${{ env.ECR_REGISTRY }}/${{ env.ECR_REPOSITORY_PREFIX }}/${SERVICE_NAME}:${{ inputs.commit_sha }}"
            NEW_TASK_DEF=$(echo "$WORKING_TASK_DEF" | jq \
              --arg NEW_IMAGE "$NEW_IMAGE" '
                # Update only the image
                .containerDefinitions[0].image = $NEW_IMAGE
                # Remove AWS-managed fields
                | del(.taskDefinitionArn, .revision, .status, .requiresAttributes, .compatibilities, .registeredAt, .registeredBy)
              ')

            # Validation: Ensure only image changed
            OLD_IMAGE=$(echo "$WORKING_TASK_DEF" | jq -r '.containerDefinitions[0].image')
            NEW_IMAGE_CHECK=$(echo "$NEW_TASK_DEF" | jq -r '.containerDefinitions[0].image')

            echo "âœ… Image update: $OLD_IMAGE â†’ $NEW_IMAGE_CHECK"

            # Verify no other changes occurred
            OLD_ENV_COUNT=$(echo "$WORKING_TASK_DEF" | jq '.containerDefinitions[0].environment | length')
            NEW_ENV_COUNT=$(echo "$NEW_TASK_DEF" | jq '.containerDefinitions[0].environment | length')

            if [ "$OLD_ENV_COUNT" != "$NEW_ENV_COUNT" ]; then
              echo "âŒ Environment variables changed unexpectedly! Old: $OLD_ENV_COUNT, New: $NEW_ENV_COUNT"
              exit 1
            fi

            OLD_SECRETS_COUNT=$(echo "$WORKING_TASK_DEF" | jq '.containerDefinitions[0].secrets | length')
            NEW_SECRETS_COUNT=$(echo "$NEW_TASK_DEF" | jq '.containerDefinitions[0].secrets | length')

            if [ "$OLD_SECRETS_COUNT" != "$NEW_SECRETS_COUNT" ]; then
              echo "âŒ Secrets changed unexpectedly! Old: $OLD_SECRETS_COUNT, New: $NEW_SECRETS_COUNT"
              exit 1
            fi

            echo "âœ… Configuration preserved - only image updated"

            # Register new task definition
            echo "$NEW_TASK_DEF" | jq '.' > taskdef-${SERVICE_NAME}.json
            NEW_TASK_ARN=$(aws ecs register-task-definition \
              --cli-input-json file://taskdef-${SERVICE_NAME}.json \
              --query 'taskDefinition.taskDefinitionArn' \
              --output text)

            echo "âœ… Registered: $NEW_TASK_ARN"

            # Deploy with new image
            echo "ðŸš€ Deploying $SERVICE_NAME with new image..."
            aws ecs update-service \
              --cluster sdt-dev-cluster \
              --service sdt-dev-${SERVICE_NAME} \
              --task-definition "$NEW_TASK_ARN" \
              --force-new-deployment \
              --no-cli-pager

            echo "Recent ECS service events for $SERVICE_NAME:"
            aws ecs describe-services \
              --cluster sdt-dev-cluster \
              --services sdt-dev-${SERVICE_NAME} \
              --query 'services[0].events[0:10].[createdAt,message]' \
              --output table || true

            echo "Waiting for $SERVICE_NAME to stabilize..."
            aws ecs wait services-stable \
              --cluster sdt-dev-cluster \
              --services sdt-dev-${SERVICE_NAME}
            echo "âœ… $SERVICE_NAME is stable!"
          }

          # Enforce dependency order: config -> discovery -> api-gateway
          deploy_one_minimal config-server
          deploy_one_minimal discovery-server
          deploy_one_minimal api-gateway

  deploy-business:
    name: Deploy Business Services (Image-Only Updates)
    runs-on: ubuntu-latest
    needs: [deploy-infra, detect-changes]
    if: inputs.enable_ecs_deploy

    strategy:
      matrix:
        service: ${{ fromJSON(needs.detect-changes.outputs.business_services_json) }}
      max-parallel: 4

    steps:
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Get current working task definition
        id: get-working-taskdef
        run: |
          SERVICE_NAME="${{ matrix.service.name }}"
          
          # Get currently deployed (working) task definition
          CURRENT_TASK_ARN=$(aws ecs describe-services \
            --cluster sdt-dev-cluster \
            --services sdt-dev-$SERVICE_NAME \
            --query 'services[0].taskDefinition' \
            --output text)
          
          if [ -z "$CURRENT_TASK_ARN" ] || [ "$CURRENT_TASK_ARN" = "None" ]; then
            echo "âŒ No current task definition found for $SERVICE_NAME"
            exit 1
          fi
          
          echo "Using working task definition: $CURRENT_TASK_ARN"
          
          # Get the full task definition
          WORKING_TASK_DEF=$(aws ecs describe-task-definition \
            --task-definition "$CURRENT_TASK_ARN" \
            --query 'taskDefinition' \
            --output json)
          
          # Store current image for comparison
          CURRENT_IMAGE=$(echo "$WORKING_TASK_DEF" | jq -r '.containerDefinitions[0].image')
          echo "Current working image: $CURRENT_IMAGE"
          
          # Store for next step
          echo "$WORKING_TASK_DEF" > current-taskdef.json
          echo "current-task-arn=$CURRENT_TASK_ARN" >> $GITHUB_OUTPUT
          echo "current-image=$CURRENT_IMAGE" >> $GITHUB_OUTPUT

      - name: Create minimal task definition update (image only)
        id: minimal-update
        run: |
          SERVICE_NAME="${{ matrix.service.name }}"
          NEW_IMAGE="${{ env.ECR_REGISTRY }}/${{ env.ECR_REPOSITORY_PREFIX }}/$SERVICE_NAME:${{ inputs.commit_sha }}"
          
          # Read the working task definition
          WORKING_TASK_DEF=$(cat current-taskdef.json)
          
          # Create new task definition with ONLY image change
          NEW_TASK_DEF=$(echo "$WORKING_TASK_DEF" | jq \
            --arg NEW_IMAGE "$NEW_IMAGE" '
              # Update only the image
              .containerDefinitions[0].image = $NEW_IMAGE
              # Remove AWS-managed fields
              | del(.taskDefinitionArn, .revision, .status, .requiresAttributes, .compatibilities, .registeredAt, .registeredBy)
            ')
          
          # Validation: Ensure only image changed
          OLD_IMAGE=$(echo "$WORKING_TASK_DEF" | jq -r '.containerDefinitions[0].image')
          NEW_IMAGE_CHECK=$(echo "$NEW_TASK_DEF" | jq -r '.containerDefinitions[0].image')
          
          echo "âœ… Image update: $OLD_IMAGE â†’ $NEW_IMAGE_CHECK"
          
          # Verify no other changes occurred
          OLD_ENV_COUNT=$(echo "$WORKING_TASK_DEF" | jq '.containerDefinitions[0].environment | length')
          NEW_ENV_COUNT=$(echo "$NEW_TASK_DEF" | jq '.containerDefinitions[0].environment | length')
          
          if [ "$OLD_ENV_COUNT" != "$NEW_ENV_COUNT" ]; then
            echo "âŒ Environment variables changed unexpectedly! Old: $OLD_ENV_COUNT, New: $NEW_ENV_COUNT"
            exit 1
          fi
          
          OLD_SECRETS_COUNT=$(echo "$WORKING_TASK_DEF" | jq '.containerDefinitions[0].secrets | length')
          NEW_SECRETS_COUNT=$(echo "$NEW_TASK_DEF" | jq '.containerDefinitions[0].secrets | length')
          
          if [ "$OLD_SECRETS_COUNT" != "$NEW_SECRETS_COUNT" ]; then
            echo "âŒ Secrets changed unexpectedly! Old: $OLD_SECRETS_COUNT, New: $NEW_SECRETS_COUNT"
            exit 1
          fi
          
          echo "âœ… Configuration preserved - only image updated"
          
          # Save for registration
          echo "$NEW_TASK_DEF" | jq '.' > taskdef.json

      - name: Register and deploy minimal update
        id: deploy-update
        run: |
          SERVICE_NAME="${{ matrix.service.name }}"
          
          # Register new task definition
          NEW_TASK_ARN=$(aws ecs register-task-definition \
            --cli-input-json file://taskdef.json \
            --query 'taskDefinition.taskDefinitionArn' \
            --output text)
          
          echo "âœ… Registered: $NEW_TASK_ARN"
          
          # Deploy with new image
          echo "ðŸš€ Deploying $SERVICE_NAME with new image..."
          aws ecs update-service \
            --cluster sdt-dev-cluster \
            --service sdt-dev-$SERVICE_NAME \
            --task-definition "$NEW_TASK_ARN" \
            --force-new-deployment \
            --no-cli-pager
          
          echo "task-arn=$NEW_TASK_ARN" >> $GITHUB_OUTPUT

      - name: Show recent ECS service events
        run: |
          aws ecs describe-services \
            --cluster sdt-dev-cluster \
            --services sdt-dev-${{ matrix.service.name }} \
            --query 'services[0].events[0:10].[createdAt,message]' \
            --output table || true

      - name: Describe latest tasks and stopped reasons
        run: |
          TASK_ARNS=$(aws ecs list-tasks \
            --cluster sdt-dev-cluster \
            --service-name sdt-dev-${{ matrix.service.name }} \
            --desired-status RUNNING \
            --output text --query 'taskArns')
          if [ -z "$TASK_ARNS" ]; then
            TASK_ARNS=$(aws ecs list-tasks \
              --cluster sdt-dev-cluster \
              --service-name sdt-dev-${{ matrix.service.name }} \
              --desired-status STOPPED \
              --output text --query 'taskArns[0:5]')
          fi
          if [ -n "$TASK_ARNS" ]; then
            aws ecs describe-tasks \
              --cluster sdt-dev-cluster \
              --tasks $TASK_ARNS \
              --query 'tasks[].{last:lastStatus,desired:desiredStatus,stopped:stoppedReason,containers:containers[].reason}' \
              --output json || true
          else
            echo "No tasks found yet."
          fi

      - name: Wait for service stability
        run: |
          echo "â³ Waiting for service to stabilize..."
          aws ecs wait services-stable \
            --cluster sdt-dev-cluster \
            --services sdt-dev-${{ matrix.service.name }}
          echo "âœ… Service ${{ matrix.service.name }} is stable!"

  health-check:
    name: Health Check Services
    runs-on: ubuntu-latest
    needs: deploy-business
    if: inputs.enable_ecs_deploy

    steps:
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Check ECS service health
        run: |
          echo "ðŸ¥ Checking health of all services..."
          SERVICES=(
            "config-server"
            "discovery-server"
            "api-gateway"
            "bff-service"
            "user-service"
            "task-service"
            "analytics-service"
            "payment-service"
            "gamification-service"
            "practice-service"
            "feedback-service"
            "notification-service"
          )

          ALL_HEALTHY=true
          for service in "${SERVICES[@]}"; do
            echo "Checking sdt-dev-$service..."
            STATUS=$(aws ecs describe-services \
              --cluster sdt-dev-cluster \
              --services sdt-dev-$service \
              --query 'services[0].{Running:runningCount,Desired:desiredCount,Status:status}' \
              --output json)
            
            RUNNING=$(echo $STATUS | jq -r '.Running')
            DESIRED=$(echo $STATUS | jq -r '.Desired')
            
            if [ "$RUNNING" -eq "$DESIRED" ] && [ "$RUNNING" -gt 0 ]; then
              echo "âœ… $service: $RUNNING/$DESIRED tasks running"
            else
              echo "âŒ $service: $RUNNING/$DESIRED tasks running"
              ALL_HEALTHY=false
            fi
          done

          if [ "$ALL_HEALTHY" = false ]; then
            echo "âš ï¸ Some services are not healthy!"
            exit 1
          fi

          echo "âœ… All services are healthy!"

      - name: Get ALB endpoint
        id: get-alb
        run: |
          ALB_DNS=$(aws elbv2 describe-load-balancers \
            --names sdt-dev-alb \
            --query 'LoadBalancers[0].DNSName' \
            --output text)
          echo "alb-dns=$ALB_DNS" >> $GITHUB_OUTPUT
          echo "ðŸ“ ALB Endpoint: http://$ALB_DNS"

  notify-slack:
    name: Notify Slack
    runs-on: ubuntu-latest
    needs: [build-and-push, deploy-infra, deploy-business, health-check]
    if: always()

    steps:
      - name: Checkout repository (required for local actions)
        uses: actions/checkout@v4

      - name: Determine status
        id: status
        run: |
          if [ "${{ needs.health-check.result }}" == "success" ]; then
            echo "status=success" >> $GITHUB_OUTPUT
            echo "emoji=:white_check_mark:" >> $GITHUB_OUTPUT
            echo "color=good" >> $GITHUB_OUTPUT
          elif [ "${{ needs.build-and-push.result }}" == "failure" ]; then
            echo "status=failed" >> $GITHUB_OUTPUT
            echo "emoji=:x:" >> $GITHUB_OUTPUT
            echo "color=danger" >> $GITHUB_OUTPUT
          else
            echo "status=partial" >> $GITHUB_OUTPUT
            echo "emoji=:warning:" >> $GITHUB_OUTPUT
            echo "color=warning" >> $GITHUB_OUTPUT
          fi

      - name: Send Slack notification
        uses: ./.github/actions/slack-notify
        with:
          webhook: ${{ secrets.SLACK_WEBHOOK_URL }}
          payload: |
            {
              "text": "${{ steps.status.outputs.emoji }} Backend Deployment to Dev",
              "attachments": [
                {
                  "color": "${{ steps.status.outputs.color }}",
                  "fields": [
                    { "title": "Status", "value": "${{ steps.status.outputs.status }}", "short": true },
                    { "title": "Environment", "value": "Dev", "short": true },
                    { "title": "PR Title", "value": "${{ inputs.pr_title }}", "short": false },
                    { "title": "Author", "value": "${{ inputs.pr_author }}", "short": true },
                    { "title": "Commit", "value": "<${{ inputs.pr_url }}|View PR>", "short": true },
                    { "title": "Build Result", "value": "${{ needs.build-and-push.result }}", "short": true },
                    { "title": "Deploy Results", "value": "infra: ${{ needs.deploy-infra.result }}, business: ${{ needs.deploy-business.result }}", "short": true },
                    { "title": "Health Check", "value": "${{ needs.health-check.result }}", "short": true }
                  ],
                  "footer": "GitHub Actions",
                  "footer_icon": "https://github.githubassets.com/favicon.ico"
                }
              ]
            }

  summary:
    name: Deployment Summary
    runs-on: ubuntu-latest
    needs: [build-and-push, deploy-infra, deploy-business, health-check]

    steps:
      - name: Generate summary
        run: |
          echo "## ðŸš€ Deployment Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

          echo "### Build & Deployment Info" >> $GITHUB_STEP_SUMMARY
          echo "- **Environment:** Dev" >> $GITHUB_STEP_SUMMARY
          echo "- **PR Title:** ${{ inputs.pr_title }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Author:** ${{ inputs.pr_author }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Target Branch:** ${{ inputs.target_branch }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Commit SHA:** \`${{ inputs.commit_sha }}\`" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

          echo "### Job Results" >> $GITHUB_STEP_SUMMARY
          echo "| Job | Status |" >> $GITHUB_STEP_SUMMARY
          echo "|-----|--------|" >> $GITHUB_STEP_SUMMARY
          echo "| Build & Push | ${{ needs.build-and-push.result }} |" >> $GITHUB_STEP_SUMMARY
          echo "| Deploy Infra | ${{ needs.deploy-infra.result }} |" >> $GITHUB_STEP_SUMMARY
          echo "| Deploy Business | ${{ needs.deploy-business.result }} |" >> $GITHUB_STEP_SUMMARY
          echo "| Health Check | ${{ needs.health-check.result }} |" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

          echo "### Services Deployed (12)" >> $GITHUB_STEP_SUMMARY
          echo "#### Infrastructure Services" >> $GITHUB_STEP_SUMMARY
          echo "- âœ… Config Server (8081)" >> $GITHUB_STEP_SUMMARY
          echo "- âœ… Discovery Server (8082)" >> $GITHUB_STEP_SUMMARY
          echo "- âœ… API Gateway (8080)" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "#### Business Services" >> $GITHUB_STEP_SUMMARY
          echo "- âœ… BFF Service (8083)" >> $GITHUB_STEP_SUMMARY
          echo "- âœ… User Service (8084)" >> $GITHUB_STEP_SUMMARY
          echo "- âœ… Task Service (8085)" >> $GITHUB_STEP_SUMMARY
          echo "- âœ… Analytics Service (8086)" >> $GITHUB_STEP_SUMMARY
          echo "- âœ… Payment Service (8087)" >> $GITHUB_STEP_SUMMARY
          echo "- âœ… Gamification Service (8088)" >> $GITHUB_STEP_SUMMARY
          echo "- âœ… Practice Service (8089)" >> $GITHUB_STEP_SUMMARY
          echo "- âœ… Feedback Service (8090)" >> $GITHUB_STEP_SUMMARY
          echo "- âœ… Notification Service (8091)" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

          echo "### Container Registry" >> $GITHUB_STEP_SUMMARY
          echo "\`\`\`" >> $GITHUB_STEP_SUMMARY
          echo "Registry: 962496666337.dkr.ecr.eu-west-1.amazonaws.com/sdt/dev/" >> $GITHUB_STEP_SUMMARY
          echo "Image Tag: ${{ inputs.commit_sha }}" >> $GITHUB_STEP_SUMMARY
          echo "\`\`\`" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

          echo "### ECS Cluster" >> $GITHUB_STEP_SUMMARY
          echo "- **Cluster:** sdt-dev-cluster" >> $GITHUB_STEP_SUMMARY
          echo "- **Region:** eu-west-1" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

          if [ "${{ needs.health-check.result }}" == "success" ]; then
            echo "### âœ… Deployment Successful!" >> $GITHUB_STEP_SUMMARY
            echo "All services are healthy and running." >> $GITHUB_STEP_SUMMARY
          else
            echo "### âš ï¸ Deployment Issues" >> $GITHUB_STEP_SUMMARY
            echo "Some jobs did not complete successfully. Check the logs above." >> $GITHUB_STEP_SUMMARY
          fi

  rollback-on-failure:
    name: Rollback Changed Services on Failure
    runs-on: ubuntu-latest
    needs: [detect-changes, deploy-infra, deploy-business, health-check]
    if: needs.health-check.result == 'failure'

    steps:
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Roll back infra services (if changed)
        if: needs.detect-changes.outputs.infra_any == 'true'
        shell: bash
        run: |
          set -euo pipefail
          IFS=',' read -r -a INFRA <<< "${{ needs.detect-changes.outputs.infra_csv }}"
          for name in "${INFRA[@]}"; do
            echo "Rolling back $name..."
            # Get previous task definition ARN (second most recent)
            PREV=$(aws ecs list-task-definitions \
              --family-prefix sdt-dev-$name \
              --sort DESC \
              --max-items 2 \
              --query 'taskDefinitionArns[-1]' \
              --output text)
            if [ -z "$PREV" ] || [ "$PREV" = "None" ]; then
              echo "No previous task definition found for $name; skipping"
              continue
            fi
            aws ecs update-service \
              --cluster sdt-dev-cluster \
              --service sdt-dev-$name \
              --task-definition "$PREV" \
              --force-new-deployment \
              --no-cli-pager
            aws ecs wait services-stable --cluster sdt-dev-cluster --services sdt-dev-$name
            echo "âœ… Rolled back $name to $PREV"
          done

      - name: Roll back business services (if changed)
        shell: bash
        run: |
          set -euo pipefail
          SERVICES_JSON='${{ needs.detect-changes.outputs.business_services_json }}'
          COUNT=$(jq 'length' <<<"$SERVICES_JSON")
          if [ "$COUNT" -eq 0 ]; then
            echo "No business services changed; nothing to roll back."
            exit 0
          fi
          for name in $(jq -r '.[].name' <<<"$SERVICES_JSON"); do
            echo "Rolling back $name..."
            PREV=$(aws ecs list-task-definitions \
              --family-prefix sdt-dev-$name \
              --sort DESC \
              --max-items 2 \
              --query 'taskDefinitionArns[-1]' \
              --output text)
            if [ -z "$PREV" ] || [ "$PREV" = "None" ]; then
              echo "No previous task definition found for $name; skipping"
              continue
            fi
            aws ecs update-service \
              --cluster sdt-dev-cluster \
              --service sdt-dev-$name \
              --task-definition "$PREV" \
              --force-new-deployment \
              --no-cli-pager
            aws ecs wait services-stable --cluster sdt-dev-cluster --services sdt-dev-$name
            echo "âœ… Rolled back $name to $PREV"
          done
