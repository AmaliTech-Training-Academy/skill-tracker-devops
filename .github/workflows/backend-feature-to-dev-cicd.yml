name: Feature to Dev CI/CD

# PIPELINE APPROACH: Minimal Task Definition Updates
# This pipeline uses a safe "image-only" update strategy:
# 1. Gets the current working task definition from ECS
# 2. Updates ONLY the container image tag (preserves all other config)
# 3. Validates no other changes occurred
# 4. Deploys the minimal update
#
# Benefits:
# - Preserves all Terraform-managed configuration
# - Eliminates configuration drift risks
# - Faster, safer deployments
# - Simple rollback (just previous task definition revision)

on:
  # This is a reusable workflow that can be called from other workflows
  workflow_call:
    # Input parameters passed from the calling workflow
    inputs:
      pr_title:
        required: true
        type: string
      pr_author:
        required: true
        type: string
      pr_url:
        required: true
        type: string
      target_branch:
        required: true
        type: string
      commit_sha:
        required: true
        type: string
      enable_ecs_deploy:
        required: false
        type: boolean
        default: true
      force_full_build:
        required: false
        type: boolean
        default: false
    # Required secrets for AWS authentication, Docker registry, and notifications
    secrets:
      AWS_ACCESS_KEY_ID:
        required: true
      AWS_SECRET_ACCESS_KEY:
        required: true
      SLACK_WEBHOOK_URL:
        required: false
      PERSONAL_ACCESS_TOKEN:
        required: true
      BACKEND_REPO_NAME:
        required: true
      ARN_APP_SECRETS_JWT:
        required: true
      ARN_APP_SECRETS_OAUTH_GOOGLE:
        required: true
      ARN_APP_SECRETS_MAIL:
        required: true
      ARN_APP_SECRETS_MQ:
        required: true
      ARN_APP_SECRETS_REDIS:
        required: false
      ARN_APP_SECRETS_MONGO_ANALYTICS:
        required: true
      ARN_APP_SECRETS_MONGO_GAMIFICATION:
        required: true
      ARN_APP_SECRETS_MONGO_NOTIFICATION:
        required: true
      ARN_APP_SECRETS_POSTGRES_SCHEMAS:
        required: false

env:
  AWS_REGION: eu-west-1
  ECR_REGISTRY: 962496666337.dkr.ecr.eu-west-1.amazonaws.com
  ECR_REPOSITORY_PREFIX: sdt/dev

jobs:
  detect-changes:
    name: Detect Changed Services
    runs-on: ubuntu-latest

    outputs:
      services_json: ${{ steps.compute.outputs.services_json }}
      business_services_json: ${{ steps.compute.outputs.business_services_json }}
      infra_any: ${{ steps.compute.outputs.infra_any }}
      infra_csv: ${{ steps.compute.outputs.infra_csv }}

    steps:
      - name: Checkout backend repository (full history)
        uses: actions/checkout@v4
        with:
          repository: ${{ secrets.BACKEND_REPO_NAME }}
          ref: ${{ inputs.commit_sha }}
          token: ${{ secrets.PERSONAL_ACCESS_TOKEN }}
          fetch-depth: 0

      - name: Install jq
        run: |
          sudo apt-get update
          sudo apt-get install -y jq

      - name: Compute changed services matrix
        id: compute
        shell: bash
        run: |
          set -euo pipefail

          # Define services mapping
          # FOCUS SERVICES ONLY: Core infrastructure + User service + Data services
          NAMES=(
            config-server discovery-server api-gateway
            user-service
          )
          PATHS=(
            skilltracker-infra/config-server
            skilltracker-infra/discovery-server
            skilltracker-infra/api-gateway
            skilltracker-services/user-service
          )
          PORTS=(8081 8082 8080 8084)

          # If manual override is enabled, output all services and exit
          if [ "${{ inputs.force_full_build }}" = "true" ]; then
            echo "force_full_build enabled: selecting ALL services"
            SERVICES_JSON='[]'
            BUSINESS_JSON='[]'
            INFRA_CSV="config-server,discovery-server,api-gateway"
            for i in "${!NAMES[@]}"; do
              name="${NAMES[$i]}"; path="${PATHS[$i]}"; port="${PORTS[$i]}"
              obj=$(jq -n --arg n "$name" --arg p "$path" --argjson port "$port" '{name:$n, path:$p, port:$port}')
              SERVICES_JSON=$(jq -c --argjson o "$obj" '. + [$o]' <<<"$SERVICES_JSON")
              case "$path" in
                skilltracker-infra/*) : ;;
                *) BUSINESS_JSON=$(jq -c --argjson o "$obj" '. + [$o]' <<<"$BUSINESS_JSON");;
              esac
            done
            echo "services_json=$SERVICES_JSON" >> "$GITHUB_OUTPUT"
            echo "business_services_json=$BUSINESS_JSON" >> "$GITHUB_OUTPUT"
            echo "infra_any=true" >> "$GITHUB_OUTPUT"
            echo "infra_csv=$INFRA_CSV" >> "$GITHUB_OUTPUT"
            exit 0
          fi

          COMMIT="${{ inputs.commit_sha }}"
          PARENT="${COMMIT}^1"
          # Fallback if parent is missing (e.g., not a merge commit)
          if ! git cat-file -e "$PARENT" 2>/dev/null; then
            PARENT="${COMMIT}^"
          fi

          echo "Comparing $PARENT..$COMMIT"
          CHANGED=$(git diff --name-only "$PARENT" "$COMMIT" || true)
          printf '%s\n' "$CHANGED"

          SERVICES_JSON='[]'
          BUSINESS_JSON='[]'
          INFRA_CSV=""

          for i in "${!NAMES[@]}"; do
            name="${NAMES[$i]}"; path="${PATHS[$i]}"; port="${PORTS[$i]}"
            if printf '%s\n' "$CHANGED" | grep -qE "^${path}/"; then
              obj=$(jq -n --arg n "$name" --arg p "$path" --argjson port "$port" '{name:$n, path:$p, port:$port}')
              SERVICES_JSON=$(jq -c --argjson o "$obj" '. + [$o]' <<<"$SERVICES_JSON")
              case "$path" in
                skilltracker-infra/*)
                  if [ -z "$INFRA_CSV" ]; then INFRA_CSV="$name"; else INFRA_CSV="$INFRA_CSV,$name"; fi
                  ;;
                *)
                  BUSINESS_JSON=$(jq -c --argjson o "$obj" '. + [$o]' <<<"$BUSINESS_JSON")
                  ;;
              esac
            fi
          done

          INFRA_ANY=false
          if [ -n "$INFRA_CSV" ]; then INFRA_ANY=true; fi

          echo "services_json=$SERVICES_JSON" >> "$GITHUB_OUTPUT"
          echo "business_services_json=$BUSINESS_JSON" >> "$GITHUB_OUTPUT"
          echo "infra_any=$INFRA_ANY" >> "$GITHUB_OUTPUT"
          echo "infra_csv=$INFRA_CSV" >> "$GITHUB_OUTPUT"

      - name: Debug changed services outputs
        run: |
          echo "services_json=${{ steps.compute.outputs.services_json }}"
          echo "business_services_json=${{ steps.compute.outputs.business_services_json }}"
          echo "infra_any=${{ steps.compute.outputs.infra_any }}"
          echo "infra_csv=${{ steps.compute.outputs.infra_csv }}"

  build-and-push:
    name: Build and Push Docker Images
    runs-on: ubuntu-latest
    needs: detect-changes
    continue-on-error: true

    strategy:
      fail-fast: false
      matrix:
        service: ${{ fromJSON(needs.detect-changes.outputs.services_json) }}

    steps:
      - name: Checkout backend repository
        uses: actions/checkout@v4
        with:
          repository: ${{ secrets.BACKEND_REPO_NAME }}
          ref: ${{ inputs.commit_sha }}
          token: ${{ secrets.PERSONAL_ACCESS_TOKEN }}
          fetch-depth: 0

      - name: Set up JDK 21
        uses: actions/setup-java@v4
        with:
          distribution: "temurin"
          java-version: "21"
          cache: "maven"

      - name: Install Maven (host)
        run: |
          sudo apt-get update
          sudo apt-get install -y maven

      - name: Build shared dependencies
        run: |
          echo "üîß Building shared dependencies first..."
          # Build common-security if it exists
          if [ -d "./common-security" ]; then
            echo "üì¶ Building common-security..."
            mvn -q clean install -DskipTests -f ./common-security/pom.xml
          elif [ -d "./shared/common-security" ]; then
            echo "üì¶ Building shared/common-security..."
            mvn -q clean install -DskipTests -f ./shared/common-security/pom.xml
          elif [ -f "./pom.xml" ]; then
            echo "üì¶ Building parent project (may include shared modules)..."
            mvn -q clean install -DskipTests -pl common-security -am 2>/dev/null || echo "No common-security module found in parent"
          else
            echo "‚ö†Ô∏è No shared dependencies found - proceeding with service build"
          fi

      - name: Prime Maven cache (host)
        run: |
          echo "üì• Downloading dependencies for ${{ matrix.service.name }}..."
          mvn -q -DskipTests -f ./${{ matrix.service.path }}/pom.xml dependency:go-offline || echo "‚ö†Ô∏è Some dependencies may be missing - will resolve during build"

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v2

      - name: Build Docker image for ${{ matrix.service.name }}
        run: |
          echo "üî® Building ${{ matrix.service.name }} on port ${{ matrix.service.port }}"
          docker build \
            -f ./${{ matrix.service.path }}/Dockerfile \
            -t ${{ env.ECR_REGISTRY }}/${{ env.ECR_REPOSITORY_PREFIX }}/${{ matrix.service.name }}:latest \
            -t ${{ env.ECR_REGISTRY }}/${{ env.ECR_REPOSITORY_PREFIX }}/${{ matrix.service.name }}:${{ inputs.commit_sha }} \
            .

      - name: Push Docker image to ECR
        run: |
          echo "üì§ Pushing ${{ matrix.service.name }} to ECR"
          docker push ${{ env.ECR_REGISTRY }}/${{ env.ECR_REPOSITORY_PREFIX }}/${{ matrix.service.name }}:latest
          docker push ${{ env.ECR_REGISTRY }}/${{ env.ECR_REPOSITORY_PREFIX }}/${{ matrix.service.name }}:${{ inputs.commit_sha }}

      - name: Image digest
        run: |
          echo "‚úÖ Successfully pushed ${{ matrix.service.name }}"
          echo "üì¶ Latest: ${{ env.ECR_REGISTRY }}/${{ env.ECR_REPOSITORY_PREFIX }}/${{ matrix.service.name }}:latest"
          echo "üì¶ Tagged: ${{ env.ECR_REGISTRY }}/${{ env.ECR_REPOSITORY_PREFIX }}/${{ matrix.service.name }}:${{ inputs.commit_sha }}"

  deploy-infra:
    name: Deploy Infra Services (Image-Only Updates, Ordered)
    runs-on: ubuntu-latest
    needs: [build-and-push, detect-changes]
    if: inputs.enable_ecs_deploy && needs.detect-changes.outputs.infra_any == 'true'

    steps:
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Deploy infra services sequentially (minimal updates)
        run: |
          set -euo pipefail

          deploy_one_minimal() {
            SERVICE_NAME="$1"
            echo "=== Deploying $SERVICE_NAME (Image-Only Update) ==="

            # Get currently deployed (working) task definition
            CURRENT_TASK_ARN=$(aws ecs describe-services \
              --cluster sdt-dev-cluster \
              --services sdt-dev-${SERVICE_NAME} \
              --query 'services[0].taskDefinition' \
              --output text || true)

            if [ -z "$CURRENT_TASK_ARN" ] || [ "$CURRENT_TASK_ARN" = "None" ]; then
              echo "‚ùå Service sdt-dev-${SERVICE_NAME} not found or has no taskDefinition. Skipping."
              return 0
            fi

            echo "Using working task definition: $CURRENT_TASK_ARN"

            # Get the full working task definition
            WORKING_TASK_DEF=$(aws ecs describe-task-definition \
              --task-definition "$CURRENT_TASK_ARN" \
              --query 'taskDefinition' \
              --output json)

            # Store current image for comparison
            CURRENT_IMAGE=$(echo "$WORKING_TASK_DEF" | jq -r '.containerDefinitions[0].image')
            echo "Current working image: $CURRENT_IMAGE"

            # Create new task definition with ONLY image change
            NEW_IMAGE="${{ env.ECR_REGISTRY }}/${{ env.ECR_REPOSITORY_PREFIX }}/${SERVICE_NAME}:${{ inputs.commit_sha }}"
            NEW_TASK_DEF=$(echo "$WORKING_TASK_DEF" | jq \
              --arg NEW_IMAGE "$NEW_IMAGE" '
                # Update only the image
                .containerDefinitions[0].image = $NEW_IMAGE
                # Remove AWS-managed fields
                | del(.taskDefinitionArn, .revision, .status, .requiresAttributes, .compatibilities, .registeredAt, .registeredBy)
              ')

            # Validation: Ensure only image changed
            OLD_IMAGE=$(echo "$WORKING_TASK_DEF" | jq -r '.containerDefinitions[0].image')
            NEW_IMAGE_CHECK=$(echo "$NEW_TASK_DEF" | jq -r '.containerDefinitions[0].image')

            echo "‚úÖ Image update: $OLD_IMAGE ‚Üí $NEW_IMAGE_CHECK"

            # Verify no other changes occurred
            OLD_ENV_COUNT=$(echo "$WORKING_TASK_DEF" | jq '.containerDefinitions[0].environment | length')
            NEW_ENV_COUNT=$(echo "$NEW_TASK_DEF" | jq '.containerDefinitions[0].environment | length')

            if [ "$OLD_ENV_COUNT" != "$NEW_ENV_COUNT" ]; then
              echo "‚ùå Environment variables changed unexpectedly! Old: $OLD_ENV_COUNT, New: $NEW_ENV_COUNT"
              exit 1
            fi

            OLD_SECRETS_COUNT=$(echo "$WORKING_TASK_DEF" | jq '.containerDefinitions[0].secrets | length')
            NEW_SECRETS_COUNT=$(echo "$NEW_TASK_DEF" | jq '.containerDefinitions[0].secrets | length')

            if [ "$OLD_SECRETS_COUNT" != "$NEW_SECRETS_COUNT" ]; then
              echo "‚ùå Secrets changed unexpectedly! Old: $OLD_SECRETS_COUNT, New: $NEW_SECRETS_COUNT"
              exit 1
            fi

            echo "‚úÖ Configuration preserved - only image updated"

            # Register new task definition
            echo "$NEW_TASK_DEF" | jq '.' > taskdef-${SERVICE_NAME}.json
            NEW_TASK_ARN=$(aws ecs register-task-definition \
              --cli-input-json file://taskdef-${SERVICE_NAME}.json \
              --query 'taskDefinition.taskDefinitionArn' \
              --output text)

            echo "‚úÖ Registered: $NEW_TASK_ARN"

            # Deploy with new image
            echo "üöÄ Deploying $SERVICE_NAME with new image..."
            aws ecs update-service \
              --cluster sdt-dev-cluster \
              --service sdt-dev-${SERVICE_NAME} \
              --task-definition "$NEW_TASK_ARN" \
              --force-new-deployment \
              --no-cli-pager

            echo "Recent ECS service events for $SERVICE_NAME:"
            aws ecs describe-services \
              --cluster sdt-dev-cluster \
              --services sdt-dev-${SERVICE_NAME} \
              --query 'services[0].events[0:10].[createdAt,message]' \
              --output table || true

            echo "Waiting for $SERVICE_NAME to stabilize..."
            aws ecs wait services-stable \
              --cluster sdt-dev-cluster \
              --services sdt-dev-${SERVICE_NAME}
            echo "‚úÖ $SERVICE_NAME is stable!"
          }

          # Enforce dependency order: config -> discovery -> api-gateway
          deploy_one_minimal config-server
          deploy_one_minimal discovery-server
          deploy_one_minimal api-gateway

  deploy-business:
    name: Deploy Business Services (Image-Only Updates)
    runs-on: ubuntu-latest
    needs: [build-and-push, deploy-infra, detect-changes]
    if: inputs.enable_ecs_deploy && always() && (needs.deploy-infra.result == 'success' || needs.deploy-infra.result == 'skipped')

    strategy:
      matrix:
        service: ${{ fromJSON(needs.detect-changes.outputs.business_services_json) }}
      max-parallel: 4

    steps:
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Get current working task definition
        id: get-working-taskdef
        run: |
          SERVICE_NAME="${{ matrix.service.name }}"

          # Get currently deployed (working) task definition
          CURRENT_TASK_ARN=$(aws ecs describe-services \
            --cluster sdt-dev-cluster \
            --services sdt-dev-$SERVICE_NAME \
            --query 'services[0].taskDefinition' \
            --output text)

          if [ -z "$CURRENT_TASK_ARN" ] || [ "$CURRENT_TASK_ARN" = "None" ]; then
            echo "‚ùå No current task definition found for $SERVICE_NAME"
            exit 1
          fi

          echo "Using working task definition: $CURRENT_TASK_ARN"

          # Get the full task definition
          WORKING_TASK_DEF=$(aws ecs describe-task-definition \
            --task-definition "$CURRENT_TASK_ARN" \
            --query 'taskDefinition' \
            --output json)

          # Store current image for comparison
          CURRENT_IMAGE=$(echo "$WORKING_TASK_DEF" | jq -r '.containerDefinitions[0].image')
          echo "Current working image: $CURRENT_IMAGE"

          # Store for next step
          echo "$WORKING_TASK_DEF" > current-taskdef.json
          echo "current-task-arn=$CURRENT_TASK_ARN" >> $GITHUB_OUTPUT
          echo "current-image=$CURRENT_IMAGE" >> $GITHUB_OUTPUT

      - name: Create minimal task definition update (image only)
        id: minimal-update
        run: |
          SERVICE_NAME="${{ matrix.service.name }}"
          NEW_IMAGE="${{ env.ECR_REGISTRY }}/${{ env.ECR_REPOSITORY_PREFIX }}/$SERVICE_NAME:${{ inputs.commit_sha }}"

          # Read the working task definition
          WORKING_TASK_DEF=$(cat current-taskdef.json)

          # Create new task definition with ONLY image change
          NEW_TASK_DEF=$(echo "$WORKING_TASK_DEF" | jq \
            --arg NEW_IMAGE "$NEW_IMAGE" '
              # Update only the image
              .containerDefinitions[0].image = $NEW_IMAGE
              # Remove AWS-managed fields
              | del(.taskDefinitionArn, .revision, .status, .requiresAttributes, .compatibilities, .registeredAt, .registeredBy)
            ')

          # Validation: Ensure only image changed
          OLD_IMAGE=$(echo "$WORKING_TASK_DEF" | jq -r '.containerDefinitions[0].image')
          NEW_IMAGE_CHECK=$(echo "$NEW_TASK_DEF" | jq -r '.containerDefinitions[0].image')

          echo "‚úÖ Image update: $OLD_IMAGE ‚Üí $NEW_IMAGE_CHECK"

          # Verify no other changes occurred
          OLD_ENV_COUNT=$(echo "$WORKING_TASK_DEF" | jq '.containerDefinitions[0].environment | length')
          NEW_ENV_COUNT=$(echo "$NEW_TASK_DEF" | jq '.containerDefinitions[0].environment | length')

          if [ "$OLD_ENV_COUNT" != "$NEW_ENV_COUNT" ]; then
            echo "‚ùå Environment variables changed unexpectedly! Old: $OLD_ENV_COUNT, New: $NEW_ENV_COUNT"
            exit 1
          fi

          OLD_SECRETS_COUNT=$(echo "$WORKING_TASK_DEF" | jq '.containerDefinitions[0].secrets | length')
          NEW_SECRETS_COUNT=$(echo "$NEW_TASK_DEF" | jq '.containerDefinitions[0].secrets | length')

          if [ "$OLD_SECRETS_COUNT" != "$NEW_SECRETS_COUNT" ]; then
            echo "‚ùå Secrets changed unexpectedly! Old: $OLD_SECRETS_COUNT, New: $NEW_SECRETS_COUNT"
            exit 1
          fi

          echo "‚úÖ Configuration preserved - only image updated"

          # Save for registration
          echo "$NEW_TASK_DEF" | jq '.' > taskdef.json

      - name: Register and deploy minimal update
        id: deploy-update
        run: |
          SERVICE_NAME="${{ matrix.service.name }}"

          # Register new task definition
          NEW_TASK_ARN=$(aws ecs register-task-definition \
            --cli-input-json file://taskdef.json \
            --query 'taskDefinition.taskDefinitionArn' \
            --output text)

          echo "‚úÖ Registered: $NEW_TASK_ARN"

          # Deploy with new image
          echo "üöÄ Deploying $SERVICE_NAME with new image..."
          aws ecs update-service \
            --cluster sdt-dev-cluster \
            --service sdt-dev-$SERVICE_NAME \
            --task-definition "$NEW_TASK_ARN" \
            --force-new-deployment \
            --no-cli-pager

          echo "task-arn=$NEW_TASK_ARN" >> $GITHUB_OUTPUT

      - name: Show recent ECS service events
        run: |
          aws ecs describe-services \
            --cluster sdt-dev-cluster \
            --services sdt-dev-${{ matrix.service.name }} \
            --query 'services[0].events[0:10].[createdAt,message]' \
            --output table || true

      - name: Describe latest tasks and stopped reasons
        run: |
          TASK_ARNS=$(aws ecs list-tasks \
            --cluster sdt-dev-cluster \
            --service-name sdt-dev-${{ matrix.service.name }} \
            --desired-status RUNNING \
            --output text --query 'taskArns')
          if [ -z "$TASK_ARNS" ]; then
            TASK_ARNS=$(aws ecs list-tasks \
              --cluster sdt-dev-cluster \
              --service-name sdt-dev-${{ matrix.service.name }} \
              --desired-status STOPPED \
              --output text --query 'taskArns[0:5]')
          fi
          if [ -n "$TASK_ARNS" ]; then
            aws ecs describe-tasks \
              --cluster sdt-dev-cluster \
              --tasks $TASK_ARNS \
              --query 'tasks[].{last:lastStatus,desired:desiredStatus,stopped:stoppedReason,containers:containers[].reason}' \
              --output json || true
          else
            echo "No tasks found yet."
          fi

      - name: Wait for service stability
        run: |
          echo "‚è≥ Waiting for service to stabilize..."
          aws ecs wait services-stable \
            --cluster sdt-dev-cluster \
            --services sdt-dev-${{ matrix.service.name }}
          echo "‚úÖ Service ${{ matrix.service.name }} is stable!"

  health-check:
    name: Health Check Services
    runs-on: ubuntu-latest
    needs: [deploy-infra, deploy-business]
    if: inputs.enable_ecs_deploy && always() && (needs.deploy-infra.result == 'success' || needs.deploy-infra.result == 'skipped') && (needs.deploy-business.result == 'success' || needs.deploy-business.result == 'skipped')

    steps:
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Check ECS service health
        run: |
          echo "üè• Checking health of all services..."
          SERVICES=(
            "config-server"
            "discovery-server"
            "api-gateway"
            "user-service"
          )

          ALL_HEALTHY=true
          for service in "${SERVICES[@]}"; do
            echo "Checking sdt-dev-$service..."
            STATUS=$(aws ecs describe-services \
              --cluster sdt-dev-cluster \
              --services sdt-dev-$service \
              --query 'services[0].{Running:runningCount,Desired:desiredCount,Status:status}' \
              --output json)
            
            RUNNING=$(echo $STATUS | jq -r '.Running')
            DESIRED=$(echo $STATUS | jq -r '.Desired')
            
            if [ "$RUNNING" -eq "$DESIRED" ] && [ "$RUNNING" -gt 0 ]; then
              echo "‚úÖ $service: $RUNNING/$DESIRED tasks running"
            else
              echo "‚ùå $service: $RUNNING/$DESIRED tasks running"
              ALL_HEALTHY=false
            fi
          done

          if [ "$ALL_HEALTHY" = false ]; then
            echo "‚ö†Ô∏è Some services are not healthy!"
            exit 1
          fi

          echo "‚úÖ All services are healthy!"

      - name: Get ALB endpoint
        id: get-alb
        run: |
          ALB_DNS=$(aws elbv2 describe-load-balancers \
            --names sdt-dev-alb \
            --query 'LoadBalancers[0].DNSName' \
            --output text)
          echo "alb-dns=$ALB_DNS" >> $GITHUB_OUTPUT
          echo "üìç ALB Endpoint: http://$ALB_DNS"

  # Stage-specific failure notifications
  notify-build-failure:
    name: Notify Build Failure
    runs-on: ubuntu-latest
    needs: [build-and-push, detect-changes]
    if: failure() && needs.build-and-push.result == 'failure'

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Get build failure details
        id: build-details
        run: |
          # Get failed services from the matrix
          CHANGED_SERVICES='${{ needs.detect-changes.outputs.services_json }}'
          FAILED_SERVICES=""

          # Check which services were supposed to be built
          for service in $(echo "$CHANGED_SERVICES" | jq -r '.[]'); do
            FAILED_SERVICES="$FAILED_SERVICES\n‚Ä¢ $service"
          done

          echo "failed-services<<EOF" >> $GITHUB_OUTPUT
          echo -e "$FAILED_SERVICES" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT

      - name: Send build failure notification
        uses: ./.github/actions/slack-notify
        with:
          webhook: ${{ secrets.SLACK_WEBHOOK_URL }}
          payload: |
            {
              "text": ":x: Build Failed - Backend Deployment to Dev",
              "attachments": [
                {
                  "color": "danger",
                  "fields": [
                    { "title": "‚ùå Failure Stage", "value": "Build & Push", "short": true },
                    { "title": "Environment", "value": "Dev", "short": true },
                    { "title": "PR Title", "value": "${{ inputs.pr_title }}", "short": false },
                    { "title": "Author", "value": "${{ inputs.pr_author }}", "short": true },
                    { "title": "Commit", "value": "<${{ inputs.pr_url }}|View PR>", "short": true },
                    { "title": "Failed Services", "value": "${{ steps.build-details.outputs.failed-services }}", "short": false },
                    { "title": "Action Required", "value": "Check build logs for compilation errors, dependency issues, or Docker build failures", "short": false },
                    { "title": "View Logs", "value": "<${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}|GitHub Actions>", "short": true }
                  ],
                  "footer": "GitHub Actions - Build Failure",
                  "footer_icon": "https://github.githubassets.com/favicon.ico"
                }
              ]
            }

  notify-deploy-failure:
    name: Notify Deployment Failure
    runs-on: ubuntu-latest
    needs: [build-and-push, deploy-infra, deploy-business, detect-changes]
    if: failure() && (needs.deploy-infra.result == 'failure' || needs.deploy-business.result == 'failure')

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Get deployment failure details
        id: deploy-details
        run: |
          FAILURE_STAGE=""
          FAILED_SERVICES=""
          TROUBLESHOOTING=""

          if [ "${{ needs.deploy-infra.result }}" == "failure" ]; then
            FAILURE_STAGE="Infrastructure Deployment"
            FAILED_SERVICES="‚Ä¢ config-server\n‚Ä¢ discovery-server\n‚Ä¢ api-gateway"
            TROUBLESHOOTING="Check ECS service events, task definition registration, and service dependencies"
          elif [ "${{ needs.deploy-business.result }}" == "failure" ]; then
            FAILURE_STAGE="Business Services Deployment"
            CHANGED_SERVICES='${{ needs.detect-changes.outputs.business_services_json }}'
            for service in $(echo "$CHANGED_SERVICES" | jq -r '.[].name'); do
              FAILED_SERVICES="$FAILED_SERVICES\n‚Ä¢ $service"
            done
            TROUBLESHOOTING="Check ECS service stability, task health checks, and service startup logs"
          fi

          echo "failure-stage=$FAILURE_STAGE" >> $GITHUB_OUTPUT
          echo "failed-services<<EOF" >> $GITHUB_OUTPUT
          echo -e "$FAILED_SERVICES" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT
          echo "troubleshooting=$TROUBLESHOOTING" >> $GITHUB_OUTPUT

      - name: Get ECS service status
        id: ecs-status
        run: |
          SERVICES=("config-server" "discovery-server" "api-gateway" "user-service")
          SERVICE_STATUS=""

          for service in "${SERVICES[@]}"; do
            STATUS=$(aws ecs describe-services \
              --cluster sdt-dev-cluster \
              --services sdt-dev-$service \
              --query 'services[0].{running:runningCount,desired:desiredCount,status:status}' \
              --output json 2>/dev/null || echo '{"running":0,"desired":0,"status":"NOT_FOUND"}')
            
            RUNNING=$(echo "$STATUS" | jq -r '.running // 0')
            DESIRED=$(echo "$STATUS" | jq -r '.desired // 0')
            SVC_STATUS=$(echo "$STATUS" | jq -r '.status // "UNKNOWN"')
            
            if [ "$RUNNING" == "$DESIRED" ] && [ "$DESIRED" != "0" ]; then
              SERVICE_STATUS="$SERVICE_STATUS\n‚úÖ $service: $RUNNING/$DESIRED ($SVC_STATUS)"
            else
              SERVICE_STATUS="$SERVICE_STATUS\n‚ùå $service: $RUNNING/$DESIRED ($SVC_STATUS)"
            fi
          done

          echo "service-status<<EOF" >> $GITHUB_OUTPUT
          echo -e "$SERVICE_STATUS" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT

      - name: Send deployment failure notification
        uses: ./.github/actions/slack-notify
        with:
          webhook: ${{ secrets.SLACK_WEBHOOK_URL }}
          payload: |
            {
              "text": ":warning: Deployment Failed - Backend Deployment to Dev",
              "attachments": [
                {
                  "color": "danger",
                  "fields": [
                    { "title": "‚ùå Failure Stage", "value": "${{ steps.deploy-details.outputs.failure-stage }}", "short": true },
                    { "title": "Environment", "value": "Dev", "short": true },
                    { "title": "PR Title", "value": "${{ inputs.pr_title }}", "short": false },
                    { "title": "Author", "value": "${{ inputs.pr_author }}", "short": true },
                    { "title": "Commit", "value": "<${{ inputs.pr_url }}|View PR>", "short": true },
                    { "title": "Failed Services", "value": "${{ steps.deploy-details.outputs.failed-services }}", "short": false },
                    { "title": "Current Service Status", "value": "${{ steps.ecs-status.outputs.service-status }}", "short": false },
                    { "title": "Troubleshooting", "value": "${{ steps.deploy-details.outputs.troubleshooting }}", "short": false },
                    { "title": "View Logs", "value": "<${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}|GitHub Actions>", "short": true }
                  ],
                  "footer": "GitHub Actions - Deployment Failure",
                  "footer_icon": "https://github.githubassets.com/favicon.ico"
                }
              ]
            }

  notify-health-failure:
    name: Notify Health Check Failure
    runs-on: ubuntu-latest
    needs: [build-and-push, deploy-infra, deploy-business, health-check]
    if: failure() && needs.health-check.result == 'failure'

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Get detailed health check status
        id: health-details
        run: |
          SERVICES=(
            "config-server"
            "discovery-server"
            "api-gateway"
            "user-service"
          )

          UNHEALTHY_SERVICES=""
          HEALTHY_SERVICES=""
          RECENT_EVENTS=""

          for service in "${SERVICES[@]}"; do
            # Get service status
            SERVICE_INFO=$(aws ecs describe-services \
              --cluster sdt-dev-cluster \
              --services sdt-dev-$service \
              --query 'services[0]' \
              --output json 2>/dev/null || echo '{}')
            
            RUNNING=$(echo "$SERVICE_INFO" | jq -r '.runningCount // 0')
            DESIRED=$(echo "$SERVICE_INFO" | jq -r '.desiredCount // 0')
            
            if [ "$RUNNING" == "$DESIRED" ] && [ "$DESIRED" != "0" ]; then
              HEALTHY_SERVICES="$HEALTHY_SERVICES\n‚úÖ $service: $RUNNING/$DESIRED tasks"
            else
              UNHEALTHY_SERVICES="$UNHEALTHY_SERVICES\n‚ùå $service: $RUNNING/$DESIRED tasks"
              
              # Get recent events for unhealthy services
              EVENTS=$(aws ecs describe-services \
                --cluster sdt-dev-cluster \
                --services sdt-dev-$service \
                --query 'services[0].events[0:3].[createdAt,message]' \
                --output text 2>/dev/null | head -3)
              
              RECENT_EVENTS="$RECENT_EVENTS\n\n**$service events:**\n$EVENTS"
            fi
          done

          echo "unhealthy-services<<EOF" >> $GITHUB_OUTPUT
          echo -e "$UNHEALTHY_SERVICES" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT

          echo "healthy-services<<EOF" >> $GITHUB_OUTPUT
          echo -e "$HEALTHY_SERVICES" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT

          echo "recent-events<<EOF" >> $GITHUB_OUTPUT
          echo -e "$RECENT_EVENTS" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT

      - name: Send health check failure notification
        uses: ./.github/actions/slack-notify
        with:
          webhook: ${{ secrets.SLACK_WEBHOOK_URL }}
          payload: |
            {
              "text": ":rotating_light: Health Check Failed - Backend Deployment to Dev",
              "attachments": [
                {
                  "color": "danger",
                  "fields": [
                    { "title": "‚ùå Failure Stage", "value": "Health Check", "short": true },
                    { "title": "Environment", "value": "Dev", "short": true },
                    { "title": "PR Title", "value": "${{ inputs.pr_title }}", "short": false },
                    { "title": "Author", "value": "${{ inputs.pr_author }}", "short": true },
                    { "title": "Commit", "value": "<${{ inputs.pr_url }}|View PR>", "short": true },
                    { "title": "‚ùå Unhealthy Services", "value": "${{ steps.health-details.outputs.unhealthy-services }}", "short": false },
                    { "title": "‚úÖ Healthy Services", "value": "${{ steps.health-details.outputs.healthy-services }}", "short": false },
                    { "title": "Recent Events", "value": "${{ steps.health-details.outputs.recent-events }}", "short": false },
                    { "title": "Action Required", "value": "Automatic rollback initiated. Check ECS task logs and service events.", "short": false },
                    { "title": "View Logs", "value": "<${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}|GitHub Actions>", "short": true }
                  ],
                  "footer": "GitHub Actions - Health Check Failure",
                  "footer_icon": "https://github.githubassets.com/favicon.ico"
                }
              ]
            }

  notify-slack:
    name: Notify Success
    runs-on: ubuntu-latest
    needs: [build-and-push, deploy-infra, deploy-business, health-check]
    if: always() && needs.build-and-push.result == 'success' && (needs.deploy-infra.result == 'success' || needs.deploy-infra.result == 'skipped') && (needs.deploy-business.result == 'success' || needs.deploy-business.result == 'skipped') && needs.health-check.result == 'success'

    steps:
      - name: Checkout repository (required for local actions)
        uses: actions/checkout@v4

      - name: Send success notification
        uses: ./.github/actions/slack-notify
        with:
          webhook: ${{ secrets.SLACK_WEBHOOK_URL }}
          payload: |
            {
              "text": ":white_check_mark: Deployment Successful - Backend to Dev",
              "attachments": [
                {
                  "color": "good",
                  "fields": [
                    { "title": "‚úÖ Status", "value": "All stages completed successfully", "short": true },
                    { "title": "Environment", "value": "Dev", "short": true },
                    { "title": "PR Title", "value": "${{ inputs.pr_title }}", "short": false },
                    { "title": "Author", "value": "${{ inputs.pr_author }}", "short": true },
                    { "title": "Commit", "value": "<${{ inputs.pr_url }}|View PR>", "short": true },
                    { "title": "Build Result", "value": "‚úÖ ${{ needs.build-and-push.result }}", "short": true },
                    { "title": "Deploy Results", "value": "‚úÖ infra: ${{ needs.deploy-infra.result }}, business: ${{ needs.deploy-business.result }}", "short": true },
                    { "title": "Health Check", "value": "‚úÖ ${{ needs.health-check.result }}", "short": true },
                    { "title": "View Details", "value": "<${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}|GitHub Actions>", "short": true }
                  ],
                  "footer": "GitHub Actions - Deployment Success",
                  "footer_icon": "https://github.githubassets.com/favicon.ico"
                }
              ]
            }

  summary:
    name: Deployment Summary
    runs-on: ubuntu-latest
    needs: [build-and-push, deploy-infra, deploy-business, health-check]
    if: always()

    steps:
      - name: Generate summary
        run: |
          echo "## üöÄ Deployment Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

          echo "### Build & Deployment Info" >> $GITHUB_STEP_SUMMARY
          echo "- **Environment:** Dev" >> $GITHUB_STEP_SUMMARY
          echo "- **PR Title:** ${{ inputs.pr_title }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Author:** ${{ inputs.pr_author }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Target Branch:** ${{ inputs.target_branch }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Commit SHA:** \`${{ inputs.commit_sha }}\`" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

          echo "### Job Results" >> $GITHUB_STEP_SUMMARY
          echo "| Job | Status |" >> $GITHUB_STEP_SUMMARY
          echo "|-----|--------|" >> $GITHUB_STEP_SUMMARY
          echo "| Build & Push | ${{ needs.build-and-push.result }} |" >> $GITHUB_STEP_SUMMARY
          echo "| Deploy Infra | ${{ needs.deploy-infra.result }} |" >> $GITHUB_STEP_SUMMARY
          echo "| Deploy Business | ${{ needs.deploy-business.result }} |" >> $GITHUB_STEP_SUMMARY
          echo "| Health Check | ${{ needs.health-check.result }} |" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

          echo "### Services Deployed (12)" >> $GITHUB_STEP_SUMMARY
          echo "#### Infrastructure Services" >> $GITHUB_STEP_SUMMARY
          echo "- ‚úÖ Config Server (8081)" >> $GITHUB_STEP_SUMMARY
          echo "- ‚úÖ Discovery Server (8082)" >> $GITHUB_STEP_SUMMARY
          echo "- ‚úÖ API Gateway (8080)" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "#### Business Services" >> $GITHUB_STEP_SUMMARY
          echo "- ‚úÖ BFF Service (8083)" >> $GITHUB_STEP_SUMMARY
          echo "- ‚úÖ User Service (8084)" >> $GITHUB_STEP_SUMMARY
          echo "- ‚úÖ Task Service (8085)" >> $GITHUB_STEP_SUMMARY
          echo "- ‚úÖ Analytics Service (8086)" >> $GITHUB_STEP_SUMMARY
          echo "- ‚úÖ Payment Service (8087)" >> $GITHUB_STEP_SUMMARY
          echo "- ‚úÖ Gamification Service (8088)" >> $GITHUB_STEP_SUMMARY
          echo "- ‚úÖ Practice Service (8089)" >> $GITHUB_STEP_SUMMARY
          echo "- ‚úÖ Feedback Service (8090)" >> $GITHUB_STEP_SUMMARY
          echo "- ‚úÖ Notification Service (8091)" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

          echo "### Container Registry" >> $GITHUB_STEP_SUMMARY
          echo "\`\`\`" >> $GITHUB_STEP_SUMMARY
          echo "Registry: 962496666337.dkr.ecr.eu-west-1.amazonaws.com/sdt/dev/" >> $GITHUB_STEP_SUMMARY
          echo "Image Tag: ${{ inputs.commit_sha }}" >> $GITHUB_STEP_SUMMARY
          echo "\`\`\`" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

          echo "### ECS Cluster" >> $GITHUB_STEP_SUMMARY
          echo "- **Cluster:** sdt-dev-cluster" >> $GITHUB_STEP_SUMMARY
          echo "- **Region:** eu-west-1" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

          if [ "${{ needs.health-check.result }}" == "success" ]; then
            echo "### ‚úÖ Deployment Successful!" >> $GITHUB_STEP_SUMMARY
            echo "All services are healthy and running." >> $GITHUB_STEP_SUMMARY
          else
            echo "### ‚ö†Ô∏è Deployment Issues" >> $GITHUB_STEP_SUMMARY
            echo "Some jobs did not complete successfully. Check the logs above." >> $GITHUB_STEP_SUMMARY
          fi

  rollback-on-failure:
    name: Rollback Changed Services on Failure
    runs-on: ubuntu-latest
    needs: [detect-changes, deploy-infra, deploy-business, health-check]
    if: needs.health-check.result == 'failure'

    steps:
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Roll back infra services (if changed)
        if: needs.detect-changes.outputs.infra_any == 'true'
        shell: bash
        run: |
          set -euo pipefail
          IFS=',' read -r -a INFRA <<< "${{ needs.detect-changes.outputs.infra_csv }}"
          for name in "${INFRA[@]}"; do
            echo "Rolling back $name..."
            # Get previous task definition ARN (second most recent)
            PREV=$(aws ecs list-task-definitions \
              --family-prefix sdt-dev-$name \
              --sort DESC \
              --max-items 2 \
              --query 'taskDefinitionArns[-1]' \
              --output text)
            if [ -z "$PREV" ] || [ "$PREV" = "None" ]; then
              echo "No previous task definition found for $name; skipping"
              continue
            fi
            aws ecs update-service \
              --cluster sdt-dev-cluster \
              --service sdt-dev-$name \
              --task-definition "$PREV" \
              --force-new-deployment \
              --no-cli-pager
            aws ecs wait services-stable --cluster sdt-dev-cluster --services sdt-dev-$name
            echo "‚úÖ Rolled back $name to $PREV"
          done

      - name: Roll back business services (if changed)
        shell: bash
        run: |
          set -euo pipefail
          SERVICES_JSON='${{ needs.detect-changes.outputs.business_services_json }}'
          COUNT=$(jq 'length' <<<"$SERVICES_JSON")
          if [ "$COUNT" -eq 0 ]; then
            echo "No business services changed; nothing to roll back."
            exit 0
          fi
          for name in $(jq -r '.[].name' <<<"$SERVICES_JSON"); do
            echo "Rolling back $name..."
            PREV=$(aws ecs list-task-definitions \
              --family-prefix sdt-dev-$name \
              --sort DESC \
              --max-items 2 \
              --query 'taskDefinitionArns[-1]' \
              --output text)
            if [ -z "$PREV" ] || [ "$PREV" = "None" ]; then
              echo "No previous task definition found for $name; skipping"
              continue
            fi
            aws ecs update-service \
              --cluster sdt-dev-cluster \
              --service sdt-dev-$name \
              --task-definition "$PREV" \
              --force-new-deployment \
              --no-cli-pager
            aws ecs wait services-stable --cluster sdt-dev-cluster --services sdt-dev-$name
            echo "‚úÖ Rolled back $name to $PREV"
          done

      - name: Send rollback notification
        uses: ./.github/actions/slack-notify
        with:
          webhook: ${{ secrets.SLACK_WEBHOOK_URL }}
          payload: |
            {
              "text": ":arrows_counterclockwise: Automatic Rollback Completed - Backend Deployment to Dev",
              "attachments": [
                {
                  "color": "warning",
                  "fields": [
                    { "title": "üîÑ Action Taken", "value": "Automatic Rollback", "short": true },
                    { "title": "Environment", "value": "Dev", "short": true },
                    { "title": "PR Title", "value": "${{ inputs.pr_title }}", "short": false },
                    { "title": "Author", "value": "${{ inputs.pr_author }}", "short": true },
                    { "title": "Commit", "value": "<${{ inputs.pr_url }}|View PR>", "short": true },
                    { "title": "Reason", "value": "Health check failed after deployment", "short": false },
                    { "title": "Services Rolled Back", "value": "All changed services reverted to previous working versions", "short": false },
                    { "title": "Status", "value": "‚úÖ System restored to stable state", "short": false },
                    { "title": "Next Steps", "value": "Review deployment logs, fix issues, and retry deployment", "short": false },
                    { "title": "View Logs", "value": "<${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}|GitHub Actions>", "short": true }
                  ],
                  "footer": "GitHub Actions - Automatic Rollback",
                  "footer_icon": "https://github.githubassets.com/favicon.ico"
                }
              ]
            }
